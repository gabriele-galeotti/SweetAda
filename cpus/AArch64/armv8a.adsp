-----------------------------------------------------------------------------------------------------------------------
--                                                     SweetAda                                                      --
-----------------------------------------------------------------------------------------------------------------------
-- __HDS__                                                                                                           --
-- __FLN__ armv8a.ads                                                                                                --
-- __DSC__                                                                                                           --
-- __HSH__ e69de29bb2d1d6434b8b29ae775ad8c2e48c5391                                                                  --
-- __HDE__                                                                                                           --
-----------------------------------------------------------------------------------------------------------------------
-- Copyright (C) 2020-2025 Gabriele Galeotti                                                                         --
--                                                                                                                   --
-- SweetAda web page: http://sweetada.org                                                                            --
-- contact address: gabriele.galeotti@sweetada.org                                                                   --
-- This work is licensed under the terms of the MIT License.                                                         --
-- Please consult the LICENSE.txt file located in the top-level directory.                                           --
-----------------------------------------------------------------------------------------------------------------------

with System;
with Interfaces;
with Bits;

package ARMv8A
   with Preelaborate => True
   is

   --========================================================================--
   --                                                                        --
   --                                                                        --
   --                               Public part                              --
   --                                                                        --
   --                                                                        --
   --========================================================================--

   use System;
   use Interfaces;
   use Bits;

pragma Style_Checks (Off);

   ----------------------------------------------------------------------------
   -- Arm® Architecture Reference Manual
   -- for A-profile architecture
   -- ARM DDI 0487J.a (ID042523)
   ----------------------------------------------------------------------------

   ----------------------------------------------------------------------------
   -- Memory attributes (D19.2.100 .. D19.2.102)
   ----------------------------------------------------------------------------

   type Memory_Attribute_Type is new Bits_8;

   -- "device" memory

   type Device_Attribute_Type is (
      DEVICE_nGnRnE, -- Device_nGnRnE
      DEVICE_nGnRE,  -- Device_nGnRE
      DEVICE_nGRE,   -- Device_nGRE
      DEVICE_GRE     -- Device_GRE
      );

   function Device_Memory_Attribute
      (Device : Device_Attribute_Type;
       XS     : Boolean)
      return Memory_Attribute_Type;

   --  "normal" memory

   type Normal_Memory_Attribute_Type is (
      NORMAL_XS_InCOnC,          -- If FEAT_XS is implemented: Normal Inner Non-cacheable, Outer Non-cacheable memory with the XS attribute set to 0. Otherwise, UNPREDICTABLE.
      NORMAL_XS_IWTCOWTCRAnWAnT, -- If FEAT_XS is implemented: Normal Inner Write-through Cacheable, Outer Write-through Cacheable, Read-Allocate, No-Write Allocate, Non-transient memory with the XS attribute set to 0. Otherwise, UNPREDICTABLE.
      NORMAL_MTE2_TIWBOWBRAWAnT, -- If FEAT_MTE2 is implemented: Tagged Normal Inner Write-Back, Outer Write-Back, Read-Allocate, Write-Allocate Non-transient memory. Otherwise, UNPREDICTABLE.
      NORMAL                     -- everything else
      );

   type Normal_Memory_Policy_Type is (
      WTT,  -- Write-Through Transient (RW not 00)
      nC,   -- Non-cacheable (RW = 00)
      WBT,  -- Write-Back Transient (RW not 00)
      WTnT, -- Write-Through Non-transient
      WBnT  -- Write-Back Non-transient
      );

   NoAllocate : constant := 0;
   Allocate   : constant := 1;

   function Normal_Memory_Attribute
      (Attribute      : Normal_Memory_Attribute_Type;
       Inner_Policy   : Normal_Memory_Policy_Type;
       Inner_R_Policy : Bits_1;
       Inner_W_Policy : Bits_1;
       Outer_Policy   : Normal_Memory_Policy_Type;
       Outer_R_Policy : Bits_1;
       Outer_W_Policy : Bits_1)
      return Memory_Attribute_Type;

   ----------------------------------------------------------------------------
   -- C5.2 Special-purpose registers
   ----------------------------------------------------------------------------

#if ALLINT
   -- C5.2.1 ALLINT, All Interrupt Mask Bit

   type ALLINT_Type is record
      Reserved1 : Bits_13 := 0;
      ALLINT    : Boolean := False; -- All interrupt mask.
      Reserved2 : Bits_50 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ALLINT_Type use record
      Reserved1 at 0 range  0 .. 12;
      ALLINT    at 0 range 13 .. 13;
      Reserved2 at 0 range 14 .. 63;
   end record;

   function ALLINT_Read
      return ALLINT_Type
      with Inline => True;
   procedure ALLINT_Write
      (Value : in ALLINT_Type)
      with Inline => True;
#end if;

   -- C5.2.2 CurrentEL, Current Exception Level

   EL0 : constant := 2#00#;
   EL1 : constant := 2#01#;
   EL2 : constant := 2#10#;
   EL3 : constant := 2#11#;

   type EL_Type is record
      Reserved1 : Bits_2;
      EL        : Bits_2;  -- Current Exception level.
      Reserved2 : Bits_28;
      Reserved3 : Bits_32;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for EL_Type use record
      Reserved1 at 0 range  0 ..  1;
      EL        at 0 range  2 ..  3;
      Reserved2 at 0 range  4 .. 31;
      Reserved3 at 0 range 32 .. 63;
   end record;

   function CurrentEL_Read
      return EL_Type
      with Inline => True;

   -- C5.2.3 DAIF, Interrupt Mask Bits

   type DAIF_Type is record
      Reserved1 : Bits_6  := 0;
      F         : Boolean := True; -- FIQ mask bit.
      I         : Boolean := True; -- IRQ mask bit.
      A         : Boolean := True; -- SError interrupt mask bit.
      D         : Boolean := True; -- Process state D mask.
      Reserved2 : Bits_54 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for DAIF_Type use record
      Reserved1 at 0 range  0 ..  5;
      F         at 0 range  6 ..  6;
      I         at 0 range  7 ..  7;
      A         at 0 range  8 ..  8;
      D         at 0 range  9 ..  9;
      Reserved2 at 0 range 10 .. 63;
   end record;

   function DAIF_Read
      return DAIF_Type
      with Inline => True;
   procedure DAIF_Write
      (Value : in DAIF_Type)
      with Inline => True;

#if DIT
   -- C5.2.4 DIT, Data Independent Timing

   type DIT_Type is record
      Reserved1 : Bits_24 := 0;
      DIT       : Boolean := False; -- Data Independent Timing.
      Reserved2 : Bits_39 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for DIT_Type use record
      Reserved1 at 0 range  0 .. 23;
      DIT       at 0 range 24 .. 24;
      Reserved2 at 0 range 25 .. 63;
   end record;

   function DIT_Read
      return DIT_Type
      with Inline => True;
   procedure DIT_Write
      (Value : in DIT_Type)
      with Inline => True;
#end if;

   -- C5.2.5 ELR_EL1, Exception Link Register (EL1)

   function ELR_EL1_Read
      return Unsigned_64
      with Inline => True;
   procedure ELR_EL1_Write
      (Value : in Unsigned_64)
      with Inline => True;

#if ELR_EL12
   function ELR_EL12_Read
      return Unsigned_64
      with Inline => True;
   procedure ELR_EL12_Write
      (Value : in Unsigned_64)
      with Inline => True;
#end if;

   -- C5.2.6 ELR_EL2, Exception Link Register (EL2)

   function ELR_EL2_Read
      return Unsigned_64
      with Inline => True;
   procedure ELR_EL2_Write
      (Value : in Unsigned_64)
      with Inline => True;

   -- C5.2.7 ELR_EL3, Exception Link Register (EL3)

   function ELR_EL3_Read
      return Unsigned_64
      with Inline => True;
   procedure ELR_EL3_Write
      (Value : in Unsigned_64)
      with Inline => True;

   -- C5.2.8 FPCR, Floating-point Control Register

   RMode_RN : constant := 2#00#; -- Round to Nearest (RN) mode.
   RMode_RP : constant := 2#01#; -- Round towards Plus Infinity (RP) mode.
   RMode_RM : constant := 2#10#; -- Round towards Minus Infinity (RM) mode.
   RMode_RZ : constant := 2#11#; -- Round towards Zero (RZ) mode.

   type FPCR_Type is record
      FIZ       : Boolean := False;    -- Flush Inputs to Zero.
      AH        : Boolean := False;    -- Alternate Handling.
      NEP       : Boolean := False;    -- Controls how the output elements other than the lowest element of the vector are determined for Advanced SIMD scalar instructions.
      Reserved1 : Bits_5  := 0;
      IOE       : Boolean := False;    -- Invalid Operation floating-point exception trap enable.
      DZE       : Boolean := False;    -- Divide by Zero floating-point exception trap enable.
      OFE       : Boolean := False;    -- Overflow floating-point exception trap enable.
      UFE       : Boolean := False;    -- Underflow floating-point exception trap enable.
      IXE       : Boolean := False;    -- Inexact floating-point exception trap enable.
      Reserved2 : Bits_2  := 0;
      IDE       : Boolean := False;    -- Input Denormal floating-point exception trap enable.
      Len       : Bits_3  := 0;        -- This field has no function in AArch64 state, and nonzero values are ignored during execution in AArch64 state.
      FZ16      : Boolean := False;    -- Flushing denormalized numbers to zero control bit on half-precision data-processing instructions.
      Stride    : Bits_2  := 0;        -- This field has no function in AArch64 state, and nonzero values are ignored during execution in AArch64 state.
      RMode     : Bits_2  := RMode_RN; -- Rounding Mode control field.
      FZ        : Boolean := False;    -- Flushing denormalized numbers to zero control bit.
      DN        : Boolean := False;    -- Default NaN use for NaN propagation.
      AHP       : Boolean := False;    -- Alternative half-precision control bit.
      Reserved3 : Bits_5  := 0;
      Reserved4 : Bits_32 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for FPCR_Type use record
      FIZ       at 0 range  0 ..  0;
      AH        at 0 range  1 ..  1;
      NEP       at 0 range  2 ..  2;
      Reserved1 at 0 range  3 ..  7;
      IOE       at 0 range  8 ..  8;
      DZE       at 0 range  9 ..  9;
      OFE       at 0 range 10 .. 10;
      UFE       at 0 range 11 .. 11;
      IXE       at 0 range 12 .. 12;
      Reserved2 at 0 range 13 .. 14;
      IDE       at 0 range 15 .. 15;
      Len       at 0 range 16 .. 18;
      FZ16      at 0 range 19 .. 19;
      Stride    at 0 range 20 .. 21;
      RMode     at 0 range 22 .. 23;
      FZ        at 0 range 24 .. 24;
      DN        at 0 range 25 .. 25;
      AHP       at 0 range 26 .. 26;
      Reserved3 at 0 range 27 .. 31;
      Reserved4 at 0 range 32 .. 63;
   end record;

   function FPCR_Read
      return FPCR_Type
      with Inline => True;
   procedure FPCR_Write
      (Value : in FPCR_Type)
      with Inline => True;

   -- C5.2.9 FPSR, Floating-point Status Register

   type FPSR_Type is record
      IOC       : Boolean; -- Invalid Operation cumulative exception bit.
      DZC       : Boolean; -- Division by Zero cumulative exception bit.
      OFC       : Boolean; -- Overflow cumulative exception bit.
      UFC       : Boolean; -- Underflow cumulative exception bit.
      IXC       : Boolean; -- Inexact cumulative exception bit.
      Reserved1 : Bits_2;
      IDC       : Boolean; -- Input Denormal cumulative exception bit.
      Reserved2 : Bits_19;
      QC        : Boolean; -- Cumulative saturation bit, Advanced SIMD only.
      V         : Boolean; -- Overflow condition flag.
      C         : Boolean; -- Carry condition flag.
      Z         : Boolean; -- Zero condition flag.
      N         : Boolean; -- Negative condition flag.
      Reserved3 : Bits_32;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for FPSR_Type use record
      IOC       at 0 range  0 ..  0;
      DZC       at 0 range  1 ..  1;
      OFC       at 0 range  2 ..  2;
      UFC       at 0 range  3 ..  3;
      IXC       at 0 range  4 ..  4;
      Reserved1 at 0 range  5 ..  6;
      IDC       at 0 range  7 ..  7;
      Reserved2 at 0 range  8 .. 26;
      QC        at 0 range 27 .. 27;
      V         at 0 range 28 .. 28;
      C         at 0 range 29 .. 29;
      Z         at 0 range 30 .. 30;
      N         at 0 range 31 .. 31;
      Reserved3 at 0 range 32 .. 63;
   end record;

   function FPSR_Read
      return FPSR_Type
      with Inline => True;
   procedure FPSR_Write
      (Value : in FPSR_Type)
      with Inline => True;

   -- C5.2.10 NZCV, Condition Flags

   type NZCV_Type is record
      Reserved1 : Bits_28 := 0;
      V         : Boolean := False; -- Overflow condition flag.
      C         : Boolean := False; -- Carry condition flag.
      Z         : Boolean := False; -- Zero condition flag.
      N         : Boolean := False; -- Negative condition flag.
      Reserved2 : Bits_32 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for NZCV_Type use record
      Reserved1 at 0 range  0 .. 27;
      V         at 0 range 28 .. 28;
      C         at 0 range 29 .. 29;
      Z         at 0 range 30 .. 30;
      N         at 0 range 31 .. 31;
      Reserved2 at 0 range 32 .. 63;
   end record;

   function NZCV_Read
      return NZCV_Type
      with Inline => True;
   procedure NZCV_Write
      (Value : in NZCV_Type)
      with Inline => True;

#if PAN
   -- C5.2.11 PAN, Privileged Access Never

   type PAN_Type is record
      Reserved1 : Bits_22 := 0;
      PAN       : Boolean;      -- Privileged Access Never
      Reserved2 : Bits_32 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for PAN_Type use record
      Reserved1 at 0 range  0 .. 21;
      PAN       at 0 range 22 .. 22;
      Reserved2 at 0 range 23 .. 63;
   end record;

   function PAN_Read
      return PAN_Type
      with Inline => True;
   procedure PAN_Write
      (Value : in PAN_Type)
      with Inline => True;
#end if;

   ----------------------------------------------------------------------------
   -- D19.2 General system control registers
   ----------------------------------------------------------------------------

   -- D19.2.1 ACCDATA_EL1, Accelerator Data

   type ACCDATA_EL1_Type is record
      ACCDATA  : Bits_32;      -- Holds the lower 32 bits of the data that is stored by an ST64BV0, Single-copy atomic 64-byte EL0 store instruction.
      Reserved : Bits_32 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ACCDATA_EL1_Type use record
      ACCDATA  at 0 range  0 .. 31;
      Reserved at 0 range 32 .. 63;
   end record;

   function ACCDATA_EL1_Read
      return ACCDATA_EL1_Type
      with Inline => True;
   procedure ACCDATA_EL1_Write
      (Value : in ACCDATA_EL1_Type)
      with Inline => True;

   -- D19.2.2 ACTLR_EL1, Auxiliary Control Register (EL1)
   -- D19.2.3 ACTLR_EL2, Auxiliary Control Register (EL2)
   -- D19.2.4 ACTLR_EL3, Auxiliary Control Register (EL3)
   -- D19.2.5 AFSR0_EL1, Auxiliary Fault Status Register 0 (EL1)
   -- D19.2.6 AFSR0_EL2, Auxiliary Fault Status Register 0 (EL2)
   -- D19.2.7 AFSR0_EL3, Auxiliary Fault Status Register 0 (EL3)
   -- D19.2.8 AFSR1_EL1, Auxiliary Fault Status Register 1 (EL1)
   -- D19.2.9 AFSR1_EL2, Auxiliary Fault Status Register 1 (EL2)
   -- D19.2.10 AFSR1_EL3, Auxiliary Fault Status Register 1 (EL3)
   -- D19.2.11 AIDR_EL1, Auxiliary ID Register
   -- D19.2.12 AMAIR_EL1, Auxiliary Memory Attribute Indirection Register (EL1)
   -- D19.2.13 AMAIR_EL2, Auxiliary Memory Attribute Indirection Register (EL2)
   -- D19.2.14 AMAIR_EL3, Auxiliary Memory Attribute Indirection Register (EL3)
   -- D19.2.15 APDAKeyHi_EL1, Pointer Authentication Key A for Data (bits[127:64])
   -- D19.2.16 APDAKeyLo_EL1, Pointer Authentication Key A for Data (bits[63:0])
   -- D19.2.17 APDBKeyHi_EL1, Pointer Authentication Key B for Data (bits[127:64])
   -- D19.2.18 APDBKeyLo_EL1, Pointer Authentication Key B for Data (bits[63:0])
   -- D19.2.19 APGAKeyHi_EL1, Pointer Authentication Key A for Code (bits[127:64])
   -- D19.2.20 APGAKeyLo_EL1, Pointer Authentication Key A for Code (bits[63:0])
   -- D19.2.21 APIAKeyHi_EL1, Pointer Authentication Key A for Instruction (bits[127:64])
   -- D19.2.22 APIAKeyLo_EL1, Pointer Authentication Key A for Instruction (bits[63:0])
   -- D19.2.23 APIBKeyHi_EL1, Pointer Authentication Key B for Instruction (bits[127:64])
   -- D19.2.24 APIBKeyLo_EL1, Pointer Authentication Key B for Instruction (bits[63:0])

#if CCSIDR2_EL1
   -- D19.2.25 CCSIDR2_EL1, Current Cache Size ID Register 2

   type CCSIDR2_EL1_Type is record
      NumSets  : Bits_24; -- (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.
      Reserved : Bits_40;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CCSIDR2_EL1_Type use record
      NumSets  at 0 range  0 .. 23;
      Reserved at 0 range 24 .. 63;
   end record;

   function CCSIDR2_EL1_Read
      return CCSIDR2_EL1_Type
      with Inline => True;
#end if;

   -- D19.2.26 CCSIDR_EL1, Current Cache Size ID Register

   type CCSIDR_EL1_Type is record
      LineSize      : Bits_3;  -- (Log2(Number of bytes in cache line)) - 4.
      Associativity : Bits_21; -- (Associativity of cache) - 1, therefore a value of 0 indicates an associativity of 1.
      Reserved1     : Bits_8;
      NumSets       : Bits_24; -- (Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.
      Reserved2     : Bits_8;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CCSIDR_EL1_Type use record
      LineSize      at 0 range  0 ..  2;
      Associativity at 0 range  3 .. 23;
      Reserved1     at 0 range 24 .. 31;
      NumSets       at 0 range 32 .. 55;
      Reserved2     at 0 range 56 .. 63;
   end record;

   function CCSIDR_EL1_Read
      return CCSIDR_EL1_Type
      with Inline => True;

   -- D19.2.27 CLIDR_EL1, Cache Level ID Register

   type Cache_Level_Type is (
      NOCACHELEVEL,
      CACHELEVEL1,
      CACHELEVEL2,
      CACHELEVEL3,
      CACHELEVEL4,
      CACHELEVEL5,
      CACHELEVEL6,
      CACHELEVEL7
      )
      with Size => 3;
   for Cache_Level_Type use (2#000#, 2#001#, 2#010#, 2#011#,
                             2#100#, 2#101#, 2#110#, 2#111#);

   type Cache_Type is (
      NOCACHE, -- 0b000 No cache.
      ICACHE,  -- 0b001 Instruction cache only.
      DCACHE,  -- 0b010 Data cache only.
      SCACHE,  -- 0b011 Separate instruction and data caches.
      UCACHE   -- 0b100 Unified cache.
      )
      with Size => 3;
   for Cache_Type use (2#000#, 2#001#, 2#010#, 2#011#, 2#100#);

   type Tag_Cache_Type is (
      NOTAGCACHE,   -- 0b00 No Tag Cache.
      SEPALLOCTAG,  -- 0b01 Separate Allocation Tag Cache.
      UALLOCULINES, -- 0b10 Unified Allocation Tag and Data cache, Allocation Tags and Data in unified lines.
      UALLOCSLINES  -- 0b11 Unified Allocation Tag and Data cache, Allocation Tags and Data in separate lines.
      )
      with Size => 2;
   for Tag_Cache_Type use (2#00#, 2#01#, 2#10#, 2#11#);

   type CLIDR_EL1_Type is record
      Ctype1   : Cache_Type;       -- Cache Type fields.
      Ctype2   : Cache_Type;       -- ''
      Ctype3   : Cache_Type;       -- ''
      Ctype4   : Cache_Type;       -- ''
      Ctype5   : Cache_Type;       -- ''
      Ctype6   : Cache_Type;       -- ''
      Ctype7   : Cache_Type;       -- ''
      LoUIS    : Cache_Level_Type; -- Level of Unification Inner Shareable for the cache hierarchy.
      LoC      : Cache_Level_Type; -- Level of Coherence for the cache hierarchy.
      LoUU     : Cache_Level_Type; -- Level of Unification Uniprocessor for the cache hierarchy.
      ICB      : Cache_Level_Type; -- Inner cache boundary.
      Ttype1   : Tag_Cache_Type;   -- Tag cache type.
      Ttype2   : Tag_Cache_Type;   -- ''
      Ttype3   : Tag_Cache_Type;   -- ''
      Ttype4   : Tag_Cache_Type;   -- ''
      Ttype5   : Tag_Cache_Type;   -- ''
      Ttype6   : Tag_Cache_Type;   -- ''
      Ttype7   : Tag_Cache_Type;   -- ''
      Reserved : Bits_17;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CLIDR_EL1_Type use record
      Ctype1   at 0 range  0 ..  2;
      Ctype2   at 0 range  3 ..  5;
      Ctype3   at 0 range  6 ..  8;
      Ctype4   at 0 range  9 .. 11;
      Ctype5   at 0 range 12 .. 14;
      Ctype6   at 0 range 15 .. 17;
      Ctype7   at 0 range 18 .. 20;
      LoUIS    at 0 range 21 .. 23;
      LoC      at 0 range 24 .. 26;
      LoUU     at 0 range 27 .. 29;
      ICB      at 0 range 30 .. 32;
      Ttype1   at 0 range 33 .. 34;
      Ttype2   at 0 range 35 .. 36;
      Ttype3   at 0 range 37 .. 38;
      Ttype4   at 0 range 39 .. 40;
      Ttype5   at 0 range 41 .. 42;
      Ttype6   at 0 range 43 .. 44;
      Ttype7   at 0 range 45 .. 46;
      Reserved at 0 range 47 .. 63;
   end record;

   function CLIDR_EL1_Read
      return CLIDR_EL1_Type
      with Inline => True;

   -- D19.2.28 CONTEXTIDR_EL1, Context ID Register (EL1)
   -- D19.2.29 CONTEXTIDR_EL2, Context ID Register (EL2)

   -- D19.2.30 CPACR_EL1, Architectural Feature Access Control Register

   ZEN_TRAP    : constant := 2#00#; -- This control causes execution of these instructions at EL1 and EL0 to be trapped.
   ZEN_TRAPEL0 : constant := 2#01#; -- This control causes execution of these instructions at EL0 to be trapped, but does not cause execution of any instructions at EL1 to be trapped.
   ZEN_TRAP_2  : constant := 2#10#; -- This control causes execution of these instructions at EL1 and EL0 to be trapped.
   ZEN_NOTRAP  : constant := 2#11#; -- This control does not cause execution of any instructions to be trapped.

   FPEN_TRAP    : constant := 2#00#; -- This control causes execution of these instructions at EL1 and EL0 to be trapped.
   FPEN_TRAPEL0 : constant := 2#01#; -- This control causes execution of these instructions at EL0 to be trapped, but does not cause execution of any instructions at EL1 to be trapped.
   FPEN_TRAP_2  : constant := 2#10#; -- This control causes execution of these instructions at EL1 and EL0 to be trapped.
   FPEN_NOTRAP  : constant := 2#11#; -- This control does not cause execution of any instructions to be trapped.

   SMEN_TRAP    : constant := 2#00#; -- This control causes execution of these instructions at EL1 and EL0 to be trapped.
   SMEN_TRAPEL0 : constant := 2#01#; -- This control causes execution of these instructions at EL0 to be trapped, but does not cause execution of any instructions at EL1 to be trapped.
   SMEN_TRAP_2  : constant := 2#10#; -- This control causes execution of these instructions at EL1 and EL0 to be trapped.
   SMEN_NOTRAP  : constant := 2#11#; -- This control does not cause execution of any instructions to be trapped.

   TTA_NOTRAP : constant := 0; -- This control does not cause any instructions to be trapped.
   TTA_TRAP   : constant := 1; -- This control causes EL0 and EL1 System register accesses to all implemented trace registers to be trapped.

   type CPACR_EL1_Type is record
      Reserved1 : Bits_16 := 0;
      ZEN       : Bits_2;       -- Traps execution at EL1 and EL0 of SVE instructions when the PE is not in Streaming SVE mode, and instructions that directly access the ZCR_EL1 System register to EL1, or to EL2 when EL2 is implemented and enabled in the current Security state and HCR_EL2.TGE is 1.
      Reserved2 : Bits_2  := 0;
      FPEN      : Bits_2;       -- Traps execution at EL1 and EL0 of instructions that access the Advanced SIMD and floating-point registers from both Execution states to EL1, reported using ESR_ELx.EC value 0x07, or to EL2 reported using ESR_ELx.EC value 0x00 when EL2 is implemented and enabled in the current Security state and HCR_EL2.TGE is 1, as follows:• In AArch64 state, accesses to FPCR, FPSR, any of the SIMD and floating-point registers V0-V31, including their views as D0-D31 registers or S0-31 registers. • In AArch32 state, FPSCR, and any of the SIMD and floating-point registers Q0-15, including their views as D0-D31 registers or S0-31 registers.
      Reserved3 : Bits_2  := 0;
      SMEN      : Bits_2;       -- Traps execution at EL1 and EL0 of SME instructions, SVE instructions when FEAT_SVE is not implemented or the PE is in Streaming SVE mode, and instructions that directly access the SVCR or SMCR_EL1 System registers to EL1, or to EL2 when EL2 is implemented and enabled in the current Security state and HCR_EL2.TGE is 1.
      Reserved4 : Bits_2  := 0;
      TTA       : Bits_1;       -- Traps EL0 and EL1 System register accesses to all implemented trace registers from both Execution states to EL1, or to EL2 when it is implemented and enabled in the current Security state and HCR_EL2.TGE is 1, as follows:• In AArch64 state, accesses to trace registers are trapped, reported using ESR_ELx.EC value 0x18. • In AArch32 state, MRC and MCR accesses to trace registers are trapped, reported using ESR_ELx.EC value 0x05. • In AArch32 state, MRRC and MCRR accesses to trace registers are trapped, reported using ESR_ELx.EC value 0x0C.
      Reserved5 : Bits_35 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CPACR_EL1_Type use record
      Reserved1 at 0 range  0 .. 15;
      ZEN       at 0 range 16 .. 17;
      Reserved2 at 0 range 18 .. 19;
      FPEN      at 0 range 20 .. 21;
      Reserved3 at 0 range 22 .. 23;
      SMEN      at 0 range 24 .. 25;
      Reserved4 at 0 range 26 .. 27;
      TTA       at 0 range 28 .. 28;
      Reserved5 at 0 range 29 .. 63;
   end record;

   function CPACR_EL1_Read
      return CPACR_EL1_Type
      with Inline => True;
   procedure CPACR_EL1_Write
      (Value : in CPACR_EL1_Type)
      with Inline => True;

#if CPACR_EL12
   function CPACR_EL12_Read
      return CPACR_EL1_Type
      with Inline => True;
   procedure CPACR_EL12_Write
      (Value : in CPACR_EL1_Type)
      with Inline => True;
#end if;

   -- D19.2.31 CPTR_EL2, Architectural Feature Trap Register (EL2)
   -- D19.2.32 CPTR_EL3, Architectural Feature Trap Register (EL3)
   -- D19.2.33 CSSELR_EL1, Cache Size Selection Register
   -- D19.2.34 CTR_EL0, Cache Type Register
   -- D19.2.35 DACR32_EL2, Domain Access Control Register
   -- D19.2.36 DCZID_EL0, Data Cache Zero ID register
   -- D19.2.37 ESR_EL1, Exception Syndrome Register (EL1)
   -- D19.2.38 ESR_EL2, Exception Syndrome Register (EL2)
   -- D19.2.39 ESR_EL3, Exception Syndrome Register (EL3)

   -- D19.2.40 FAR_EL1, Fault Address Register (EL1)

   function FAR_EL1_Read
      return Unsigned_64
      with Inline => True;
   procedure FAR_EL1_Write
      (Value : in Unsigned_64)
      with Inline => True;

#if FAR_EL12
   function FAR_EL12_Read
      return Unsigned_64
      with Inline => True;
   procedure FAR_EL12_Write
      (Value : in Unsigned_64)
      with Inline => True;
#end if;

   -- D19.2.41 FAR_EL2, Fault Address Register (EL2)

   function FAR_EL2_Read
      return Unsigned_64
      with Inline => True;
   procedure FAR_EL2_Write
      (Value : in Unsigned_64)
      with Inline => True;

   -- D19.2.42 FAR_EL3, Fault Address Register (EL3)

   function FAR_EL3_Read
      return Unsigned_64
      with Inline => True;
   procedure FAR_EL3_Write
      (Value : in Unsigned_64)
      with Inline => True;

   -- D19.2.43 FPEXC32_EL2, Floating-Point Exception Control register

   type FPEXC32_EL2_Type is record
      IOF       : Boolean;      -- Invalid Operation floating-point exception trap enable.
      DZF       : Boolean;      -- Divide by Zero floating-point exception trap enable.
      OFF       : Boolean;      -- Overflow floating-point exception trap enable.
      UFF       : Boolean;      -- Underflow floating-point exception trap enable.
      IXF       : Boolean;      -- Inexact floating-point exception trap enable.
      Reserved1 : Bits_2  := 0;
      IDF       : Boolean;      -- Input Denormal floating-point exception trap enable.
      VECITR    : Bits_3;
      Reserved2 : Bits_15 := 0;
      TFV       : Boolean;      -- Trapped Fault Valid bit.
      VV        : Boolean;      -- VECITR valid bit.
      FP2V      : Boolean;      -- FPINST2 instruction valid bit.
      DEX       : Boolean;      -- Defined synchronous exception on floating-point execution.
      EN        : Boolean;      -- Enables access to the Advanced SIMD and floating-point functionality from all Exception levels, except that setting this field to 0 does not disable the following: ...
      EX        : Boolean;      -- Exception bit.
      Reserved3 : Bits_32 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for FPEXC32_EL2_Type use record
      IOF       at 0 range  0 ..  0;
      DZF       at 0 range  1 ..  1;
      OFF       at 0 range  2 ..  2;
      UFF       at 0 range  3 ..  3;
      IXF       at 0 range  4 ..  4;
      Reserved1 at 0 range  5 ..  6;
      IDF       at 0 range  7 ..  7;
      VECITR    at 0 range  8 .. 10;
      Reserved2 at 0 range 11 .. 25;
      TFV       at 0 range 26 .. 26;
      VV        at 0 range 27 .. 27;
      FP2V      at 0 range 28 .. 28;
      DEX       at 0 range 29 .. 29;
      EN        at 0 range 30 .. 30;
      EX        at 0 range 31 .. 31;
      Reserved3 at 0 range 32 .. 63;
   end record;

   function FPEXC32_EL2_Read
      return FPEXC32_EL2_Type
      with Inline => True;
   procedure FPEXC32_EL2_Write
      (Value : in FPEXC32_EL2_Type)
      with Inline => True;

   -- D19.2.44 GCR_EL1, Tag Control Register.
   -- D19.2.45 GMID_EL1, Multiple tag transfer ID register
   -- D19.2.46 HACR_EL2, Hypervisor Auxiliary Control Register
   -- D19.2.47 HAFGRTR_EL2, Hypervisor Activity Monitors Fine-Grained Read Trap Register

   -- D19.2.48 HCR_EL2, Hypervisor Configuration Register

   type HCR_EL2_Type is record
      VM        : Boolean;      -- Virtualization enable.
      SWIO      : Boolean;      -- Set/Way Invalidation Override.
      PTW       : Boolean;      -- Protected Table Walk.
      FMO       : Boolean;      -- Physical FIQ Routing.
      IMO       : Boolean;      -- Physical IRQ Routing.
      AMO       : Boolean;      -- Physical SError interrupt routing.
      VF        : Boolean;      -- Virtual FIQ Interrupt
      VI        : Boolean;      -- Virtual IRQ Interrupt.
      VSE       : Boolean;      -- Virtual SError interrupt.
      FB        : Boolean;      -- Force broadcast.
      BSU       : Bits_2;       -- Barrier Shareability upgrade.
      DC        : Boolean;      -- Default Cacheability.
      TWI       : Boolean;      -- Traps EL0 and EL1 execution of WFI instructions to EL2, when EL2 is enabled in the current Security state, from both Execution states, reported using EC syndrome value 0x01.
      TWE       : Boolean;      -- Traps EL0 and EL1 execution of WFE instructions to EL2, when EL2 is enabled in the current Security state, from both Execution states, reported using EC syndrome value 0x01.
      TID0      : Boolean;      -- Trap ID group 0.
      TID1      : Boolean;      -- Trap ID group 1.
      TID2      : Boolean;      -- Trap ID group 2.
      TID3      : Boolean;      -- Trap ID group 3.
      TSC       : Boolean;      -- Trap SMC instructions.
      TIDCP     : Boolean;      -- Trap IMPLEMENTATION DEFINED functionality.
      TACR      : Boolean;      -- Trap Auxiliary Control Registers.
      TSW       : Boolean;      -- Trap data or unified cache maintenance instructions that operate by Set/Way.
      TPCP      : Boolean;      -- Trap data or unified cache mainte instrs that operate to the Point of Coherency or Persistence.
      TPU       : Boolean;      -- Trap cache maintenance instructions that operate to the Point of Unification.
      TTLB      : Boolean;      -- Trap TLB maintenance instructions.
      TVM       : Boolean;      -- Trap Virtual Memory controls.
      TGE       : Boolean;      -- Trap General Exceptions, from EL0.
      TDZ       : Boolean;      -- Trap DC ZVA instructions.
      HCD       : Boolean;      -- HVC instruction disable.
      TRVM      : Boolean;      -- Trap Reads of Virtual Memory controls.
      RV        : Boolean;      -- Execution state control for lower Exception levels
      CD        : Boolean;      -- Stage 2 Data access cacheability disable.
      ID        : Boolean;      -- Stage 2 Instruction access cacheability disable.
      E2H       : Boolean;      -- EL2 Host.
      TLOR      : Boolean;      -- Trap LOR registers.
      TERR      : Boolean;      -- Trap Error record accesses.
      TEA       : Boolean;      -- Route synchronous External abort exceptions to EL2.
      MIOCNCE   : Boolean;      -- Mismatched Inner/Outer Cacheable Non-Coherency Enable, for the EL1&0 translation regimes.
      Reserved1 : Bits_1  := 0;
      APK       : Boolean;      -- Trap registers holding "key" values for Pointer Authentication.
      API       : Boolean;      -- Controls the use of instructions related to Pointer Authentication
      NV        : Boolean;      -- Nested Virtualization.
      NV1       : Boolean;      -- Nested Virtualization.
      AddrTr    : Boolean;      -- Address Translation.
      NV2       : Boolean;      -- Nested Virtualization.
      FWB       : Boolean;      -- Forced Write-Back.
      FIEN      : Boolean;      -- Fault Injection Enable.
      Reserved2 : Bits_1  := 0;
      TID4      : Boolean;      -- Trap ID group 4.
      TICAB     : Boolean;      -- Trap ICIALLUIS/IC IALLUIS cache maintenance instructions.
      AMVOFFEN  : Boolean;      -- Activity Monitors Virtual Offsets Enable.
      TOCU      : Boolean;      -- Trap cache maintenance instructions that operate to the Point of Unification.
      EnSCXT    : Boolean;      -- Enable Access to the SCXTNUM_EL1 and SCXTNUM_EL0 registers.
      TTLBIS    : Boolean;      -- Trap TLB maintenance instructions that operate on the Inner Shareable domain.
      TTLBOS    : Boolean;      -- Trap TLB maintenance instructions that operate on the Outer Shareable domain.
      ATA       : Boolean;      -- Allocation Tag Access.
      DCT       : Boolean;      -- Default Cacheability Tagging.
      TID5      : Boolean;      -- Trap ID group 5.
      TWEDEn    : Boolean;      -- TWE Delay Enable.
      TWEDEL    : Bits_4  := 0; -- TWE Delay.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for HCR_EL2_Type use record
      VM        at 0 range  0 ..  0;
      SWIO      at 0 range  1 ..  1;
      PTW       at 0 range  2 ..  2;
      FMO       at 0 range  3 ..  3;
      IMO       at 0 range  4 ..  4;
      AMO       at 0 range  5 ..  5;
      VF        at 0 range  6 ..  6;
      VI        at 0 range  7 ..  7;
      VSE       at 0 range  8 ..  8;
      FB        at 0 range  9 ..  9;
      BSU       at 0 range 10 .. 11;
      DC        at 0 range 12 .. 12;
      TWI       at 0 range 13 .. 13;
      TWE       at 0 range 14 .. 14;
      TID0      at 0 range 15 .. 15;
      TID1      at 0 range 16 .. 16;
      TID2      at 0 range 17 .. 17;
      TID3      at 0 range 18 .. 18;
      TSC       at 0 range 19 .. 19;
      TIDCP     at 0 range 20 .. 20;
      TACR      at 0 range 21 .. 21;
      TSW       at 0 range 22 .. 22;
      TPCP      at 0 range 23 .. 23;
      TPU       at 0 range 24 .. 24;
      TTLB      at 0 range 25 .. 25;
      TVM       at 0 range 26 .. 26;
      TGE       at 0 range 27 .. 27;
      TDZ       at 0 range 28 .. 28;
      HCD       at 0 range 29 .. 29;
      TRVM      at 0 range 30 .. 30;
      RV        at 0 range 31 .. 31;
      CD        at 0 range 32 .. 32;
      ID        at 0 range 33 .. 33;
      E2H       at 0 range 34 .. 34;
      TLOR      at 0 range 35 .. 35;
      TERR      at 0 range 36 .. 36;
      TEA       at 0 range 37 .. 37;
      MIOCNCE   at 0 range 38 .. 38;
      Reserved1 at 0 range 39 .. 39;
      APK       at 0 range 40 .. 40;
      API       at 0 range 41 .. 41;
      NV        at 0 range 42 .. 42;
      NV1       at 0 range 43 .. 43;
      AddrTr    at 0 range 44 .. 44;
      NV2       at 0 range 45 .. 45;
      FWB       at 0 range 46 .. 46;
      FIEN      at 0 range 47 .. 47;
      Reserved2 at 0 range 48 .. 48;
      TID4      at 0 range 49 .. 49;
      TICAB     at 0 range 50 .. 50;
      AMVOFFEN  at 0 range 51 .. 51;
      TOCU      at 0 range 52 .. 52;
      EnSCXT    at 0 range 53 .. 53;
      TTLBIS    at 0 range 54 .. 54;
      TTLBOS    at 0 range 55 .. 55;
      ATA       at 0 range 56 .. 56;
      DCT       at 0 range 57 .. 57;
      TID5      at 0 range 58 .. 58;
      TWEDEn    at 0 range 59 .. 59;
      TWEDEL    at 0 range 60 .. 63;
   end record;

   function HCR_EL2_Read
      return HCR_EL2_Type
      with Inline => True;
   procedure HCR_EL2_Write
      (Value : in HCR_EL2_Type)
      with Inline => True;

   -- D19.2.49 HCRX_EL2, Extended Hypervisor Configuration Register
   -- D19.2.50 HDFGRTR_EL2, Hypervisor Debug Fine-Grained Read Trap Register
   -- D19.2.51 HDFGWTR_EL2, Hypervisor Debug Fine-Grained Write Trap Register
   -- D19.2.52 HFGITR_EL2, Hypervisor Fine-Grained Instruction Trap Register
   -- D19.2.53 HFGRTR_EL2, Hypervisor Fine-Grained Read Trap Register
   -- D19.2.54 HFGWTR_EL2, Hypervisor Fine-Grained Write Trap Register
   -- D19.2.55 HPFAR_EL2, Hypervisor IPA Fault Address Register
   -- D19.2.56 HSTR_EL2, Hypervisor System Trap Register
   -- D19.2.57 ID_AA64AFR0_EL1, AArch64 Auxiliary Feature Register 0
   -- D19.2.58 ID_AA64AFR1_EL1, AArch64 Auxiliary Feature Register 1
   -- D19.2.59 ID_AA64DFR0_EL1, AArch64 Debug Feature Register 0
   -- D19.2.60 ID_AA64DFR1_EL1, AArch64 Debug Feature Register 1

   -- D19.2.61 ID_AA64ISAR0_EL1, AArch64 Instruction Set Attribute Register 0

   AES_NONE  : constant := 2#0000#; -- No AES instructions implemented.
   AES_YES   : constant := 2#0001#; -- AESE, AESD, AESMC, and AESIMC instructions implemented.
   AES_PMULL : constant := 2#0010#; -- As for 0b0001, plus PMULL and PMULL2 instructions operating on 64-bit source elements.

   SHA1_NONE : constant := 2#0000#; -- No SHA1 instructions implemented.
   SHA1_YES  : constant := 2#0001#; -- SHA1C, SHA1P, SHA1M, SHA1H, SHA1SU0, and SHA1SU1 instructions implemented.

   SHA2_NONE : constant := 2#0000#; -- No SHA2 instructions implemented.
   SHA2_YES  : constant := 2#0001#; -- Implements instructions: SHA256H, SHA256H2, SHA256SU0, and SHA256SU1.
   SHA2_512  : constant := 2#0010#; -- Implements instructions: SHA256H, SHA256H2, SHA256SU0, and SHA256SU1. SHA512H, SHA512H2, SHA512SU0, and SHA512SU1.

   CRC32_NONE : constant := 2#0000#; -- CRC32 instructions are not implemented.
   CRC32_YES  : constant := 2#0001#; -- CRC32B, CRC32H, CRC32W, CRC32X, CRC32CB, CRC32CH, CRC32CW, and CRC32CX instructions are implemented.

   ATOMIC_NONE : constant := 2#0000#; -- No Atomic instructions implemented.
   ATOMIC_YES  : constant := 2#0010#; -- LDADD, LDCLR, LDEOR, LDSET, LDSMAX, LDSMIN, LDUMAX, LDUMIN, CAS, CASP, and SWP instructions implemented.

   TME_NONE : constant := 2#0000#; -- TME instructions are not implemented.
   TME_YES  : constant := 2#0001#; -- TCANCEL, TCOMMIT, TSTART, and TTEST instructions are implemented.

   RDM_NONE : constant := 2#0000#; -- No RDMA instructions implemented.
   RDM_YES  : constant := 2#0001#; -- SQRDMLAH and SQRDMLSH instructions implemented.

   SHA3_NONE : constant := 2#0000#; -- No SHA3 instructions implemented.
   SHA3_YES  : constant := 2#0001#; -- EOR3, RAX1, XAR, and BCAX instructions implemented.

   SM3_NONE : constant := 2#0000#; -- No SM3 instructions implemented.
   SM3_YES  : constant := 2#0001#; -- SM3SS1, SM3TT1A, SM3TT1B, SM3TT2A, SM3TT2B, SM3PARTW1, and SM3PARTW2 instructions implemented.

   SM4_NONE : constant := 2#0000#; -- No SM4 instructions implemented.
   SM4_YES  : constant := 2#0001#; -- SM4E and SM4EKEY instructions implemented.

   DP_NONE : constant := 2#0000#; -- No Dot Product instructions implemented.
   DP_YES  : constant := 2#0001#; -- UDOT and SDOT instructions implemented.

   FHM_NONE : constant := 2#0000#; -- FMLAL and FMLSL instructions are not implemented.
   FHM_YES  : constant := 2#0001#; -- FMLAL and FMLSL instructions are implemented.

   TS_NONE : constant := 2#0000#; -- No flag manipulation instructions are implemented.
   TS_YES  : constant := 2#0001#; -- CFINV, RMIF, SETF16, and SETF8 instructions are implemented.
   TS_AXXA : constant := 2#0010#; -- CFINV, RMIF, SETF16, SETF8, AXFLAG, and XAFLAG instructions are implemented.

   TLB_NONE  : constant := 2#0000#; -- Outer Shareable and TLB range maintenance instructions are not implemented.
   TLB_YES   : constant := 2#0001#; -- Outer Shareable TLB maintenance instructions are implemented.
   TLB_RANGE : constant := 2#0010#; -- Outer Shareable and TLB range maintenance instructions are implemented.

   RNDR_NONE : constant := 2#0000#; -- No Random Number instructions are implemented.
   RNDR_YES  : constant := 2#0001#; -- RNDR and RNDRRS registers are implemented.

   type ID_AA64ISAR0_EL1_Type is record
      Reserved : Bits_4;
      AES      : Bits_4; -- Indicates support for AES instructions in AArch64 state.
      SHA1     : Bits_4; -- Indicates support for SHA1 instructions in AArch64 state.
      SHA2     : Bits_4; -- Indicates support for SHA2 instructions in AArch64 state.
      CRC32    : Bits_4; -- Indicates support for CRC32 instructions in AArch64 state.
      Atomic   : Bits_4; -- Indicates support for Atomic instructions in AArch64 state.
      TME      : Bits_4; -- Indicates support for TME instructions.
      RDM      : Bits_4; -- Indicates support for SQRDMLAH and SQRDMLSH instructions in AArch64 state.
      SHA3     : Bits_4; -- Indicates support for SHA3 instructions in AArch64 state.
      SM3      : Bits_4; -- Indicates support for SM3 instructions in AArch64 state.
      SM4      : Bits_4; -- Indicates support for SM4 instructions in AArch64 state.
      DP       : Bits_4; -- Indicates support for Dot Product instructions in AArch64 state.
      FHM      : Bits_4; -- Indicates support for FMLAL and FMLSL instructions.
      TS       : Bits_4; -- Indicates support for flag manipulation instructions.
      TLB      : Bits_4; -- Indicates support for Outer Shareable and TLB range maintenance instructions.
      RNDR     : Bits_4; -- Indicates support for Random Number instructions in AArch64 state.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64ISAR0_EL1_Type use record
      Reserved at 0 range  0 ..  3;
      AES      at 0 range  4 ..  7;
      SHA1     at 0 range  8 .. 11;
      SHA2     at 0 range 12 .. 15;
      CRC32    at 0 range 16 .. 19;
      Atomic   at 0 range 20 .. 23;
      TME      at 0 range 24 .. 27;
      RDM      at 0 range 28 .. 31;
      SHA3     at 0 range 32 .. 35;
      SM3      at 0 range 36 .. 39;
      SM4      at 0 range 40 .. 43;
      DP       at 0 range 44 .. 47;
      FHM      at 0 range 48 .. 51;
      TS       at 0 range 52 .. 55;
      TLB      at 0 range 56 .. 59;
      RNDR     at 0 range 60 .. 63;
   end record;

   function ID_AA64ISAR0_EL1_Read
      return ID_AA64ISAR0_EL1_Type
      with Inline => True;

   -- D19.2.62 ID_AA64ISAR1_EL1, AArch64 Instruction Set Attribute Register 1

   DPB_NONE  : constant := 2#0000#; -- DC CVAP not supported.
   DPB_YES   : constant := 2#0001#; -- DC CVAP supported.
   DPB_CVADP : constant := 2#0010#; -- DC CVAP and DC CVADP supported.

   APA_NONE : constant := 2#0000#; -- Address Authentication using the QARMA5 algorithm is not implemented.
   APA_1    : constant := 2#0001#; -- Address Authentication using the QARMA5 algorithm is implemented, with the HaveEnhancedPAC() and HaveEnhancedPAC2() functions returning FALSE.
   APA_2    : constant := 2#0010#; -- Address Authentication using the QARMA5 algorithm is implemented, with the HaveEnhancedPAC() function returning TRUE and the HaveEnhancedPAC2() function returning FALSE.
   APA_3    : constant := 2#0011#; -- Address Authentication using the QARMA5 algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning FALSE, the HaveFPACCombined() function returning FALSE, and the HaveEnhancedPAC() function returning FALSE.
   APA_4    : constant := 2#0100#; -- Address Authentication using the QARMA5 algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning TRUE, the HaveFPACCombined() function returning FALSE, and the HaveEnhancedPAC() function returning FALSE.
   APA_5    : constant := 2#0101#; -- Address Authentication using the QARMA5 algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning TRUE, the HaveFPACCombined() function returning TRUE, and the HaveEnhancedPAC() function returning FALSE.

   API_NONE : constant := 2#0000#; -- Address Authentication using an IMPLEMENTATION DEFINED algorithm is not implemented.
   API_1    : constant := 2#0001#; -- Address Authentication using an IMPLEMENTATION DEFINED algorithm is implemented, with the HaveEnhancedPAC() and HaveEnhancedPAC2() functions returning FALSE.
   API_2    : constant := 2#0010#; -- Address Authentication using an IMPLEMENTATION DEFINED algorithm is implemented, with the HaveEnhancedPAC() function returning TRUE, and the HaveEnhancedPAC2() function returning FALSE.
   API_3    : constant := 2#0011#; -- Address Authentication using an IMPLEMENTATION DEFINED algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, and the HaveEnhancedPAC() function returning FALSE.
   API_4    : constant := 2#0100#; -- Address Authentication using an IMPLEMENTATION DEFINED algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning TRUE, the HaveFPACCombined() function returning FALSE, and the HaveEnhancedPAC() function returning FALSE.
   API_5    : constant := 2#0101#; -- Address Authentication using an IMPLEMENTATION DEFINED algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning TRUE, the HaveFPACCombined() function returning TRUE, and the HaveEnhancedPAC() function returning FALSE.

   JSCVT_NONE : constant := 2#0000#; -- The FJCVTZS instruction is not implemented.
   JSCVT_YES  : constant := 2#0001#; -- The FJCVTZS instruction is implemented.

   FCMA_NONE : constant := 2#0000#; -- The FCMLA and FCADD instructions are not implemented.
   FCMA_YES  : constant := 2#0001#; -- The FCMLA and FCADD instructions are implemented.

   LRCPC_NONE      : constant := 2#0000#; -- RCpc instructions are not implemented.
   LRCPC_YES       : constant := 2#0001#; -- The no offset LDAPR, LDAPRB, and LDAPRH instructions are implemented.
   LRCPC_LDAPRSTLR : constant := 2#0010#; -- As 0b0001, and the LDAPR (unscaled immediate) and STLR (unscaled immediate) instructions are implemented.

   GPA_NONE : constant := 2#0000#; -- Generic Authentication using the QARMA5 algorithm is not implemented.
   GPA_YES  : constant := 2#0001#; -- Generic Authentication using the QARMA5 algorithm is implemented. This includes the PACGA instruction.

   GPI_NONE : constant := 2#0000#; -- Generic Authentication using an IMPLEMENTATION DEFINED algorithm is not implemented.
   GPI_YES  : constant := 2#0001#; -- Generic Authentication using an IMPLEMENTATION DEFINED algorithm is implemented. This includes the PACGA instruction.

   FRINTTS_NONE : constant := 2#0000#; -- FRINT32Z, FRINT32X, FRINT64Z, and FRINT64X instructions are not implemented.
   FRINTTS_YES  : constant := 2#0001#; -- FRINT32Z, FRINT32X, FRINT64Z, and FRINT64X instructions are implemented.

   SB_NONE : constant := 2#0000#; -- SB instruction is not implemented.
   SB_YES  : constant := 2#0001#; -- SB instruction is implemented.

   SPECRES_NONE : constant := 2#0000#; -- Prediction invalidation instructions are not implemented.
   SPECRES_YES  : constant := 2#0001#; -- CFP RCTX, DVP RCTX and CPP RCTX instructions are implemented.

   BF16_NONE    : constant := 2#0000#; -- BFloat16 instructions are not implemented.
   BF16_YES     : constant := 2#0001#; -- BFCVT, BFCVTN, BFCVTN2, BFDOT, BFMLALB, BFMLALT, and BFMMLA instructions are implemented.
   BF16_FPCREBF : constant := 2#0010#; -- As 0b0001, but the FPCR.EBF field is also supported.

   DGH_NONE : constant := 2#0000#; -- Data Gathering Hint is not implemented.
   DGH_YES  : constant := 2#0001#; -- Data Gathering Hint is implemented.

   I8MM_NONE : constant := 2#0000#; -- Int8 matrix multiplication instructions are not implemented.
   I8MM_YES  : constant := 2#0001#; -- SMMLA, SUDOT, UMMLA, USMMLA, and USDOT instructions are implemented.

   XS_NONE : constant := 2#0000#; -- The XS attribute, the TLBI and DSB instructions with the nXS qualifier, and the HCRX_EL2.{FGTnXS, FnXS} fields are not supported.
   XS_YES  : constant := 2#0001#; -- The XS attribute, the TLBI and DSB instructions with the nXS qualifier, and the HCRX_EL2.{FGTnXS, FnXS} fields are supported.

   LS64_NONE   : constant := 2#0000#; -- The LD64B, ST64B, ST64BV, and ST64BV0 instructions, the ACCDATA_EL1 register, and associated traps are not supported.
   LS64_YES    : constant := 2#0001#; -- The LD64B and ST64B instructions are supported.
   LS64_TRAPS1 : constant := 2#0010#; -- The LD64B, ST64B, and ST64BV instructions, and their associated traps are supported.
   LS64_TRAPS2 : constant := 2#0011#; -- The LD64B, ST64B, ST64BV, and ST64BV0 instructions, the ACCDATA_EL1 register, and their associated traps are supported.

   type ID_AA64ISAR1_EL1_Type is record
      DPB     : Bits_4; -- Data Persistence writeback. Indicates support for the DC CVAP and DC CVADP instructions in AArch64 state.
      APA     : Bits_4; -- Indicates whether the QARMA5 algorithm is implemented in the PE for address authentication, in AArch64 state.
      API     : Bits_4; -- Indicates whether an IMPLEMENTATION DEFINED algorithm is implemented in the PE for address authentication, in AArch64 state.
      JSCVT   : Bits_4; -- Indicates support for JavaScript conversion from double precision floating point values to integers in AArch64 state.
      FCMA    : Bits_4; -- Indicates support for complex number addition and multiplication, where numbers are stored in vectors.
      LRCPC   : Bits_4; -- Indicates support for weaker release consistency, RCpc, based model.
      GPA     : Bits_4; -- Indicates whether the QARMA5 algorithm is implemented in the PE for generic code authentication in AArch64 state.
      GPI     : Bits_4; -- Indicates support for an IMPLEMENTATION DEFINED algorithm is implemented in the PE for generic code authentication in AArch64 state.
      FRINTTS : Bits_4; -- Indicates support for the FRINT32Z, FRINT32X, FRINT64Z, and FRINT64X instructions are implemented.
      SB      : Bits_4; -- Indicates support for SB instruction in AArch64 state.
      SPECRES : Bits_4; -- Indicates support for prediction invalidation instructions in AArch64 state.
      BF16    : Bits_4; -- Indicates support for Advanced SIMD and Floating-point BFloat16 instructions in AArch64 state.
      DGH     : Bits_4; -- Indicates support for the Data Gathering Hint instruction.
      I8MM    : Bits_4; -- Indicates support for Advanced SIMD and Floating-point Int8 matrix multiplication instructions in AArch64 state.
      XS      : Bits_4; -- Indicates support for the XS attribute, the TLBI and DSB instructions with the nXS qualifier, and the HCRX_EL2.{FGTnXS, FnXS} fields in AArch64 state.
      LS64    : Bits_4; -- Indicates support for LD64B and ST64B* instructions, and the ACCDATA_EL1 register.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64ISAR1_EL1_Type use record
      DPB     at 0 range  0 ..  3;
      APA     at 0 range  4 ..  7;
      API     at 0 range  8 .. 11;
      JSCVT   at 0 range 12 .. 15;
      FCMA    at 0 range 16 .. 19;
      LRCPC   at 0 range 20 .. 23;
      GPA     at 0 range 24 .. 27;
      GPI     at 0 range 28 .. 31;
      FRINTTS at 0 range 32 .. 35;
      SB      at 0 range 36 .. 39;
      SPECRES at 0 range 40 .. 43;
      BF16    at 0 range 44 .. 47;
      DGH     at 0 range 48 .. 51;
      I8MM    at 0 range 52 .. 55;
      XS      at 0 range 56 .. 59;
      LS64    at 0 range 60 .. 63;
   end record;

   function ID_AA64ISAR1_EL1_Read
      return ID_AA64ISAR1_EL1_Type
      with Inline => True;

   -- D19.2.63 ID_AA64ISAR2_EL1, AArch64 Instruction Set Attribute Register 2

   WFxT_NONE : constant := 2#0000#; -- WFET and WFIT are not supported.
   WFxT_YES  : constant := 2#0010#; -- WFET and WFIT are supported, and the register number is reported in the ESR_ELx on exceptions.

   RPRES_NONE : constant := 2#0000#; -- When FPCR.AH == 1: Reciprocal and reciprocal square root estimates give 8 bits of mantissa, when FPCR.AH is 1.
   RPRES_YES  : constant := 2#0001#; -- When FPCR.AH == 1: Reciprocal and reciprocal square root estimates give 12 bits of mantissa, when FPCR.AH is 1.

   GPA3_NONE : constant := 2#0000#; -- Generic Authentication using the QARMA3 algorithm is not implemented.
   GPA3_YES  : constant := 2#0001#; -- Generic Authentication using the QARMA3 algorithm is implemented. This includes the PACGA instruction.

   APA3_NONE : constant := 2#0000#; -- Address Authentication using the QARMA3 algorithm is not implemented.
   APA3_1    : constant := 2#0001#; -- Address Authentication using the QARMA3 algorithm is implemented, with the HaveEnhancedPAC() and HaveEnhancedPAC2() functions returning FALSE.
   APA3_2    : constant := 2#0010#; -- Address Authentication using the QARMA3 algorithm is implemented, with the HaveEnhancedPAC() function returning TRUE and the HaveEnhancedPAC2() function returning FALSE.
   APA3_3    : constant := 2#0011#; -- Address Authentication using the QARMA3 algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning FALSE, the HaveFPACCombined() function returning FALSE, and the HaveEnhancedPAC() function returning FALSE.
   APA3_4    : constant := 2#0100#; -- Address Authentication using the QARMA3 algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning TRUE, the HaveFPACCombined() function returning FALSE, and the HaveEnhancedPAC() function returning FALSE.
   APA3_5    : constant := 2#0101#; -- Address Authentication using the QARMA3 algorithm is implemented, with the HaveEnhancedPAC2() function returning TRUE, the HaveFPAC() function returning TRUE, the HaveFPACCombined() function returning TRUE, and the HaveEnhancedPAC() function returning FALSE.

   MOPS_NONE : constant := 2#0000#; -- The Memory Copy and Memory Set instructions are not implemented in AArch64 state.
   MOPS_YES  : constant := 2#0001#; -- The Memory Copy and Memory Set instructions are implemented in AArch64 state with the following exception. If FEAT_MTE is implemented, then SETGP*, SETGM* and SETGE* instructions are also supported.

   BC_NONE : constant := 2#0000#; -- BC instruction is not implemented.
   BC_YES  : constant := 2#0001#; -- BC instruction is implemented.

   PAC_NONE : constant := 2#0000#; -- ConstPACField() returns FALSE.
   PAC_YES  : constant := 2#0001#; -- ConstPACField() returns TRUE.

   type ID_AA64ISAR2_EL1_Type is record
      WFxT     : Bits_4;  -- Indicates support for the WFET and WFIT instructions in AArch64 state.
      RPRES    : Bits_4;  -- Indicates support for 12 bits of mantissa in reciprocal and reciprocal square root instructions in AArch64 state, when FPCR.AH is 1.
      GPA3     : Bits_4;  -- Indicates whether the QARMA3 algorithm is implemented in the PE for generic code authentication in AArch64 state.
      APA3     : Bits_4;  -- Indicates whether the QARMA3 algorithm is implemented in the PE for address authentication in AArch64 state.
      MOPS     : Bits_4;  -- Indicates support for the Memory Copy and Memory Set instructions in AArch64 state.
      BC       : Bits_4;  -- Indicates support for the BC instruction in AArch64 state.
      PAC      : Bits_4;  -- Indicates whether the ConstPACField() function used as part of the PAC addition returns FALSE or TRUE.
      Reserved : Bits_36;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64ISAR2_EL1_Type use record
      WFxT     at 0 range  0 ..  3;
      RPRES    at 0 range  4 ..  7;
      GPA3     at 0 range  8 .. 11;
      APA3     at 0 range 12 .. 15;
      MOPS     at 0 range 16 .. 19;
      BC       at 0 range 20 .. 23;
      PAC      at 0 range 24 .. 27;
      Reserved at 0 range 28 .. 63;
   end record;

   function ID_AA64ISAR2_EL1_Read
      return ID_AA64ISAR2_EL1_Type
      with Inline => True;

   -- D19.2.64 ID_AA64MMFR0_EL1, AArch64 Memory Model Feature Register 0

   PARange_4GB   : constant := 2#0000#; -- 32 bits, 4GB.
   PARange_64GB  : constant := 2#0001#; -- 36 bits, 64GB.
   PARange_1TB   : constant := 2#0010#; -- 40 bits, 1TB.
   PARange_4TB   : constant := 2#0011#; -- 42 bits, 4TB.
   PARange_16TB  : constant := 2#0100#; -- 44 bits, 16TB.
   PARange_256TB : constant := 2#0101#; -- 48 bits, 256TB.
   PARange_4PB   : constant := 2#0110#; -- When FEAT_LPA is implemented or FEAT_LPA2 is implemented: 52 bits, 4PB.

   ASIDBits_8  : constant := 2#0000#; -- 8 bits.
   ASIDBits_16 : constant := 2#0010#; -- 16 bits.

   BigEnd_NONE  : constant := 2#0000#; -- No mixed-endian support.
   BigEnd_MIXED : constant := 2#0001#; -- Mixed-endian support.

   SNSMem_NONE : constant := 2#0000#; -- Does not support a distinction between Secure and Non-secure Memory.
   SNSMem_YES  : constant := 2#0001#; -- Does support a distinction between Secure and Non-secure Memory.

   BigEndEL0_NONE : constant := 2#0000#; -- No mixed-endian support at EL0. The SCTLR_EL1.E0E bit has a fixed value.
   BigEndEL0_YES  : constant := 2#0001#; -- Mixed-endian support at EL0. The SCTLR_EL1.E0E bit can be configured.

   TGran16_NONE : constant := 2#0000#; -- 16KB granule not supported.
   TGran16_YES  : constant := 2#0001#; -- 16KB granule supported.
   TGran16_52   : constant := 2#0010#; -- When FEAT_LPA2 is implemented: 16KB granule supports 52-bit input addresses and can describe 52-bit output addresses.

   TGran64_NONE : constant := 2#0000#; -- 64KB granule supported.
   TGran64_YES  : constant := 2#1111#; -- 64KB granule not supported.

   TGran4_YES  : constant := 2#0000#; -- 4KB granule supported.
   TGran4_52   : constant := 2#0001#; -- When FEAT_LPA2 is implemented: 4KB granule supports 52-bit input addresses and can describe 52-bit output addresses.
   TGran4_NONE : constant := 2#1111#; -- 4KB granule not supported.

   TGran16_2_TGran16 : constant := 2#0000#; -- Support for 16KB granule at stage 2 is identified in the ID_AA64MMFR0_EL1.TGran16 field.
   TGran16_2_NONE    : constant := 2#0001#; -- 16KB granule not supported at stage 2.
   TGran16_2_YES     : constant := 2#0010#; -- 16KB granule supported at stage 2.
   TGran16_2_52      : constant := 2#0011#; -- When FEAT_LPA2 is implemented: 16KB granule at stage 2 supports 52-bit input addresses and can describe 52-bit output addresses.

   TGran64_2_TGran64 : constant := 2#0000#; -- Support for 64KB granule at stage 2 is identified in the ID_AA64MMFR0_EL1.TGran64 field.
   TGran64_2_NONE    : constant := 2#0001#; -- 64KB granule not supported at stage 2.
   TGran64_2_YES     : constant := 2#0010#; -- 64KB granule supported at stage 2.

   TGran4_2_TGran4 : constant := 2#0000#; -- Support for 4KB granule at stage 2 is identified in the ID_AA64MMFR0_EL1.TGran4 field.
   TGran4_2_NONE   : constant := 2#0001#; -- 4KB granule not supported at stage 2.
   TGran4_2_YES    : constant := 2#0010#; -- 4KB granule supported at stage 2.
   TGran4_2_52     : constant := 2#0011#; -- When FEAT_LPA2 is implemented: 4KB granule at stage 2 supports 52-bit input addresses and can describe 52-bit output addresses.

   ExS_ALL        : constant := 2#0000#; -- All exception entries and exits are context synchronization events.
   ExS_NONCONTEXT : constant := 2#0001#; -- Non-context synchronizing exception entry and exit are supported.

   FGT_NONE : constant := 2#0000#; -- Fine-grained trap controls are not implemented.
   FGT_YES  : constant := 2#0001#; -- Fine-grained trap controls are implemented.

   ECV_NONE     : constant := 2#0000#; -- Enhanced Counter Virtualization is not implemented.
   ECV_YES      : constant := 2#0001#; -- Enhanced Counter Virtualization is implemented.
   ECV_ENHANCED : constant := 2#0010#; -- As 0b0001, and also includes support for CNTHCTL_EL2.ECV and CNTPOFF_EL2.

   type ID_AA64MMFR0_EL1_Type is record
      PARange   : Bits_4; -- Physical Address range supported.
      ASIDBits  : Bits_4; -- Number of ASID bits.
      BigEnd    : Bits_4; -- Indicates support for mixed-endian configuration.
      SNSMem    : Bits_4; -- Indicates support for a distinction between Secure and Non-secure Memory.
      BigEndEL0 : Bits_4; -- Indicates support for mixed-endian at EL0 only.
      TGran16   : Bits_4; -- Indicates support for 16KB memory translation granule size.
      TGran64   : Bits_4; -- Indicates support for 64KB memory translation granule size.
      TGran4    : Bits_4; -- Indicates support for 4KB memory translation granule size.
      TGran16_2 : Bits_4; -- Indicates support for 16KB memory granule size at stage 2.
      TGran64_2 : Bits_4; -- Indicates support for 64KB memory granule size at stage 2.
      TGran4_2  : Bits_4; -- Indicates support for 4KB memory granule size at stage 2.
      ExS       : Bits_4; -- Indicates support for disabling context synchronizing exception entry and exit.
      Reserved  : Bits_8;
      FGT       : Bits_4; -- Indicates presence of the Fine-Grained Trap controls.
      ECV       : Bits_4; -- Indicates presence of Enhanced Counter Virtualization.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64MMFR0_EL1_Type use record
      PARange   at 0 range  0 ..  3;
      ASIDBits  at 0 range  4 ..  7;
      BigEnd    at 0 range  8 .. 11;
      SNSMem    at 0 range 12 .. 15;
      BigEndEL0 at 0 range 16 .. 19;
      TGran16   at 0 range 20 .. 23;
      TGran64   at 0 range 24 .. 27;
      TGran4    at 0 range 28 .. 31;
      TGran16_2 at 0 range 32 .. 35;
      TGran64_2 at 0 range 36 .. 39;
      TGran4_2  at 0 range 40 .. 43;
      ExS       at 0 range 44 .. 47;
      Reserved  at 0 range 48 .. 55;
      FGT       at 0 range 56 .. 59;
      ECV       at 0 range 60 .. 63;
   end record;

   function ID_AA64MMFR0_EL1_Read
      return ID_AA64MMFR0_EL1_Type
      with Inline => True;

   -- D19.2.65 ID_AA64MMFR1_EL1, AArch64 Memory Model Feature Register 1

   HAFDBS_NONE  : constant := 2#0000#; -- Hardware update of the Access flag and dirty state are not supported.
   HAFDBS_AF    : constant := 2#0001#; -- Support for hardware update of the Access flag for Block and Page descriptors.
   HAFDBS_DIRTY : constant := 2#0010#; -- As 0b0001, and adds support for hardware update of the Access flag for Block and Page descriptors. Hardware update of dirty state is supported.

   VMIDBits_8  : constant := 2#0000#; -- 8 bits
   VMIDBits_16 : constant := 2#0010#; -- 16 bits

   VH_NONE : constant := 2#0000#; -- Virtualization Host Extensions not supported.
   VH_YES  : constant := 2#0001#; -- Virtualization Host Extensions supported.

   HPDS_NONE     : constant := 2#0000#; -- Disabling of hierarchical controls not supported.
   HPDS_YES      : constant := 2#0001#; -- Disabling of hierarchical controls supported with the TCR_EL1.{HPD1, HPD0}, TCR_EL2.HPD or TCR_EL2.{HPD1, HPD0}, and TCR_EL3.HPD bits.
   HPDS_ENHANCED : constant := 2#0010#; -- As for value 0b0001, and adds possible hardware allocation of bits[62:59] of the Translation table descriptors from the final lookup level for IMPLEMENTATION DEFINED use.

   LO_NONE : constant := 2#0000#; -- LORegions not supported.
   LO_YES  : constant := 2#0001#; -- LORegions supported.

   PAN_NONE : constant := 2#0000#; -- PAN not supported.
   PAN_YES  : constant := 2#0001#; -- PAN supported.
   PAN_ENH1 : constant := 2#0010#; -- PAN supported and AT S1E1RP and AT S1E1WP instructions supported.
   PAN_ENH2 : constant := 2#0011#; -- PAN supported, AT S1E1RP and AT S1E1WP instructions supported, and SCTLR_EL1.EPAN and SCTLR_EL2.EPAN bits supported.

   SpecSEI_NONE : constant := 2#0000#; -- The PE never generates an SError interrupt due to an External abort on a speculative read.
   SpecSEI_YES  : constant := 2#0001#; -- The PE might generate an SError interrupt due to an External abort on a speculative read.

   XNX_NONE : constant := 2#0000#; -- Distinction between EL0 and EL1 execute-never control at stage 2 not supported.
   XNX_YES  : constant := 2#0001#; -- Distinction between EL0 and EL1 execute-never control at stage 2 supported.

   TWED_NONE : constant := 2#0000#; -- Configurable delayed trapping of WFE is not supported.
   TWED_YES  : constant := 2#0001#; -- Configurable delayed trapping of WFE is supported.

   ETS_NONE : constant := 2#0000#; -- Enhanced Translation Synchronization is not supported.
   ETS_YES  : constant := 2#0001#; -- Enhanced Translation Synchronization is supported.

   HCX_NONE : constant := 2#0000#; -- HCRX_EL2 and its associated EL3 trap are not supported.
   HCX_YES  : constant := 2#0001#; -- HCRX_EL2 and its associated EL3 trap are supported.

   AFP_NONE : constant := 2#0000#; -- The FPCR.{AH, FIZ, NEP} fields are not supported.
   AFP_YES  : constant := 2#0001#; -- The FPCR.{AH, FIZ, NEP} fields are supported.

   nTLBPA_WNC  : constant := 2#0000#; -- The intermediate caching of translation table walks might include non-coherent physical translation caches.
   nTLBPA_WONC : constant := 2#0001#; -- The intermediate caching of translation table walks does not include non-coherent physical translation caches.

   TIDCP1_NONE : constant := 2#0000#; -- SCTLR_EL1.TIDCP and SCTLR_EL2.TIDCP bits are not implemented and are RES0.
   TIDCP1_YES  : constant := 2#0001#; -- SCTLR_EL1.TIDCP bit is implemented. If EL2 is implemented, SCTLR_EL2.TIDCP bit is implemented.

   CMOW_NONE : constant := 2#0000#; -- SCTLR_EL1.CMOW, SCTLR_EL2.CMOW, and HCRX_EL2.CMOW bits are not implemented.
   CMOW_YES  : constant := 2#0001#; -- SCTLR_EL1.CMOW is implemented. If EL2 is implemented, SCTLR_EL2.CMOW and HCRX_EL2.CMOW bits are implemented.

   type ID_AA64MMFR1_EL1_Type is record
      HAFDBS   : Bits_4; -- Hardware updates to Access flag and Dirty state in translation tables.
      VMIDBits : Bits_4; -- Number of VMID bits.
      VH       : Bits_4; -- Virtualization Host Extensions.
      HPDS     : Bits_4; -- Hierarchical Permission Disables.
      LO       : Bits_4; -- LORegions.
      PAN      : Bits_4; -- Privileged Access Never.
      SpecSEI  : Bits_4; -- Describes whether the PE can generate SError interrupt exceptions from speculative reads of memory, including speculative instruction fetches.
      XNX      : Bits_4; -- Indicates support for execute-never control distinction by Exception level at stage 2.
      TWED     : Bits_4; -- Indicates support for the configurable delayed trapping of WFE.
      ETS      : Bits_4; -- Indicates support for Enhanced Translation Synchronization.
      HCX      : Bits_4; -- Indicates support for HCRX_EL2 and its associated EL3 trap.
      AFP      : Bits_4; -- Indicates support for FPCR.{AH, FIZ, NEP}.
      nTLBPA   : Bits_4; -- Indicates support for intermediate caching of translation table walks.
      TIDCP1   : Bits_4; -- Indicates whether SCTLR_EL1.TIDCP and SCTLR_EL2.TIDCP are implemented in AArch64 state.
      CMOW     : Bits_4; -- Indicates support for cache maintenance instruction permission.
      Reserved : Bits_4;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64MMFR1_EL1_Type use record
      HAFDBS   at 0 range  0 ..  3;
      VMIDBits at 0 range  4 ..  7;
      VH       at 0 range  8 .. 11;
      HPDS     at 0 range 12 .. 15;
      LO       at 0 range 16 .. 19;
      PAN      at 0 range 20 .. 23;
      SpecSEI  at 0 range 24 .. 27;
      XNX      at 0 range 28 .. 31;
      TWED     at 0 range 32 .. 35;
      ETS      at 0 range 36 .. 39;
      HCX      at 0 range 40 .. 43;
      AFP      at 0 range 44 .. 47;
      nTLBPA   at 0 range 48 .. 51;
      TIDCP1   at 0 range 52 .. 55;
      CMOW     at 0 range 56 .. 59;
      Reserved at 0 range 60 .. 63;
   end record;

   function ID_AA64MMFR1_EL1_Read
      return ID_AA64MMFR1_EL1_Type
      with Inline => True;

   -- D19.2.66 ID_AA64MMFR2_EL1, AArch64 Memory Model Feature Register 2

   CnP_NONE : constant := 2#0000#; -- Common not Private translations not supported.
   CnP_YES  : constant := 2#0001#; -- Common not Private translations supported.

   UAO_NONE : constant := 2#0000#; -- UAO not supported.
   UAO_YES  : constant := 2#0001#; -- UAO supported.

   LSM_NONE : constant := 2#0000#; -- LSMAOE and nTLSMD bits not supported.
   LSM_YES  : constant := 2#0001#; -- LSMAOE and nTLSMD bits supported.

   IESB_NONE : constant := 2#0000#; -- IESB bit in the SCTLR_ELx registers is not supported.
   IESB_YES  : constant := 2#0001#; -- IESB bit in the SCTLR_ELx registers is supported.

   VARange_48 : constant := 2#0000#; -- VMSAv8-64 supports 48-bit VAs.
   VARange_52 : constant := 2#0001#; -- VMSAv8-64 supports 52-bit VAs when using the 64KB translation granule.

   CCIDX_32 : constant := 2#0000#; -- 32-bit format implemented for all levels of the CCSIDR_EL1.
   CCIDX_64 : constant := 2#0001#; -- 64-bit format implemented for all levels of the CCSIDR_EL1.

   NV_NONE    : constant := 2#0000#; -- Nested virtualization is not supported.
   NV_HCREL2  : constant := 2#0001#; -- The HCR_EL2.{AT, NV1, NV} bits are implemented.
   NV_VNCREL2 : constant := 2#0010#; -- The VNCR_EL2 register and the HCR_EL2.{NV2, AT, NV1, NV} bits are implemented.

   ST_39     : constant := 2#0000#; -- The maximum value of the TCR_ELx.{T0SZ,T1SZ} and VTCR_EL2.T0SZ fields is 39.
   ST_47OR48 : constant := 2#0001#; -- The maximum value of the TCR_ELx.{T0SZ,T1SZ} and VTCR_EL2.T0SZ fields is 48 for 4KB and 16KB granules, and 47 for 64KB granules.

   A_T_NONE : constant := 2#0000#; -- Unaligned single-copy atomicity and atomic functions are not supported.
   A_T_YES  : constant := 2#0001#; -- Unaligned single-copy atomicity and atomic functions with a 16-byte address range aligned to 16-bytes are supported.

   IDS_EC0  : constant := 2#0000#; -- An exception which is generated by a read access to the feature ID space, other than a trap caused by HCR_EL2.TIDx, SCTLR_EL1.UCT, or SCTLR_EL2.UCT, is reported by ESR_ELx.EC == 0x0.
   IDS_EC18 : constant := 2#0001#; -- All exceptions generated by an AArch64 read access to the feature ID space are reported by ESR_ELx.EC == 0x18.

   FWB_NONE : constant := 2#0000#; -- HCR_EL2.FWB bit is not supported.
   FWB_YES  : constant := 2#0001#; -- HCR_EL2.FWB is supported.

   TTL_NONE : constant := 2#0000#; -- TLB maintenance instructions by address have bits[47:44] as RES0.
   TTL_YES  : constant := 2#0001#; -- TLB maintenance instructions by address have bits[47:44] holding the TTL field.

   BBM_L0 : constant := 2#0000#; -- Level 0 support for changing block size is supported.
   BBM_L1 : constant := 2#0001#; -- Level 1 support for changing block size is supported.
   BBM_L2 : constant := 2#0010#; -- Level 2 support for changing block size is supported.

   EVT_NONE          : constant := 2#0000#; -- HCR_EL2.{TTLBOS, TTLBIS, TOCU, TICAB, TID4} traps are not supported.
   EVT_TOCUTICABTID4 : constant := 2#0001#; -- HCR_EL2.{TOCU, TICAB, TID4} traps are supported. HCR_EL2.{TTLBOS, TTLBIS} traps are not supported.
   EVT_ALL           : constant := 2#0010#; -- HCR_EL2.{TTLBOS, TTLBIS, TOCU, TICAB, TID4} traps are supported.

   E0PD_NONE : constant := 2#0000#; -- E0PDx mechanism is not implemented.
   E0PD_YES  : constant := 2#0001#; -- E0PDx mechanism is implemented.

   type ID_AA64MMFR2_EL1_Type is record
      CnP      : Bits_4; -- Indicates support for Common not Private translations.
      UAO      : Bits_4; -- User Access Override.
      LSM      : Bits_4; -- Indicates support for LSMAOE and nTLSMD bits in SCTLR_EL1 and SCTLR_EL2.
      IESB     : Bits_4; -- Indicates support for the IESB bit in the SCTLR_ELx registers.
      VARange  : Bits_4; -- Indicates support for a larger virtual address.
      CCIDX    : Bits_4; -- Support for the use of revised CCSIDR_EL1 register format.
      NV       : Bits_4; -- Nested Virtualization.
      ST       : Bits_4; -- Identifies support for small translation tables.
      A_T      : Bits_4; -- Identifies support for unaligned single-copy atomicity and atomic functions.
      IDS      : Bits_4; -- Indicates the value of ESR_ELx.EC that reports an exception generated by a read access to the feature ID space.
      FWB      : Bits_4; -- Indicates support for HCR_EL2.FWB.
      Reserved : Bits_4;
      TTL      : Bits_4; -- Indicates support for TTL field in address operations.
      BBM      : Bits_4; -- Allows identification of the requirements of the hardware to have break-before-make sequences when changing block size for a translation.
      EVT      : Bits_4; -- Enhanced Virtualization Traps.
      E0PD     : Bits_4; -- Indicates support for the E0PD mechanism.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64MMFR2_EL1_Type use record
      CnP      at 0 range  0 ..  3;
      UAO      at 0 range  4 ..  7;
      LSM      at 0 range  8 .. 11;
      IESB     at 0 range 12 .. 15;
      VARange  at 0 range 16 .. 19;
      CCIDX    at 0 range 20 .. 23;
      NV       at 0 range 24 .. 27;
      ST       at 0 range 28 .. 31;
      A_T      at 0 range 32 .. 35;
      IDS      at 0 range 36 .. 39;
      FWB      at 0 range 40 .. 43;
      Reserved at 0 range 44 .. 47;
      TTL      at 0 range 48 .. 51;
      BBM      at 0 range 52 .. 55;
      EVT      at 0 range 56 .. 59;
      E0PD     at 0 range 60 .. 63;
   end record;

   function ID_AA64MMFR2_EL1_Read
      return ID_AA64MMFR2_EL1_Type
      with Inline => True;

   -- D19.2.67 ID_AA64MMFR3_EL1, AArch64 Memory Model Feature Register 3

   TCRX_NONE : constant := 2#0000#; -- TCR2_EL1, TCR2_EL2 and their associated trap controls are not implemented.
   TCRX_YES  : constant := 2#0001#; -- TCR2_EL1, TCR2_EL2 and their associated trap controls are implemented.

   SCTLRX_NONE : constant := 2#0000#; -- SCTLR2_EL1, SCTLR2_EL2 and their associated trap controls are not implemented.
   SCTLRX_YES  : constant := 2#0001#; -- SCTLR2_EL1, SCTLR2_EL2 and their associated trap controls are implemented.

   MEC_NONE : constant := 2#0000#; -- Memory Encryption Contexts is not supported.
   MEC_YES  : constant := 2#0001#; -- Memory Encryption Contexts is supported for Realm physical address space.

   Spec_FPACC_NONE : constant := 2#0000#; -- The implementation does not disclose whether the speculative use of pointers processed by a PAC Authentication is materially different in terms of the impact on cached microarchitectural state between passing and failing of the PAC Authentication.
   Spec_FPACC_YES  : constant := 2#0001#; -- The speculative use of pointers processed by a PAC Authentication is not materially different in terms of the impact on cached microarchitectural state between passing and failing of the PAC Authentication.

   type ID_AA64MMFR3_EL1_Type is record
      TCRX       : Bits_4;  -- TCR Extension.
      SCTLRX     : Bits_4;  -- SCTLRX Extension.
      Reserved1  : Bits_20;
      MEC        : Bits_4;  -- Indicates support for Memory Encryption Contexts.
      Reserved2  : Bits_28;
      Spec_FPACC : Bits_4;  -- Speculative behavior in the event of a PAC authentication failure in an implementation that includes FEAT_FPACCOMBINE.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64MMFR3_EL1_Type use record
      TCRX       at 0 range  0 ..  3;
      SCTLRX     at 0 range  4 ..  7;
      Reserved1  at 0 range  8 .. 27;
      MEC        at 0 range 28 .. 31;
      Reserved2  at 0 range 32 .. 59;
      Spec_FPACC at 0 range 60 .. 63;
   end record;

   function ID_AA64MMFR3_EL1_Read
      return ID_AA64MMFR3_EL1_Type
      with Inline => True;

   -- D19.2.68 ID_AA64MMFR4_EL1, AArch64 Memory Model Feature Register 4

   -- D19.2.69 ID_AA64PFR0_EL1, AArch64 Processor Feature Register 0

   EL0_64   : constant := 2#0001#; -- EL0 can be executed in AArch64 state only.
   EL0_3264 : constant := 2#0010#; -- EL0 can be executed in either AArch64 or AArch32 state.

   String_EL0      : aliased constant String := "EL0 Exception level handling";
   String_EL0_64   : aliased constant String := "EL0_64";
   String_EL0_3264 : aliased constant String := "EL0_3264";
   MsgPtr_EL0      : constant access constant String := String_EL0'Access;
   MsgPtr_EL0_64   : constant access constant String := String_EL0_64'Access;
   MsgPtr_EL0_3264 : constant access constant String := String_EL0_3264'Access;

   EL1_64   : constant := 2#0001#; -- EL1 can be executed in AArch64 state only.
   EL1_3264 : constant := 2#0010#; -- EL1 can be executed in either AArch64 or AArch32 state.

   String_EL1      : aliased constant String := "EL1 Exception level handling";
   String_EL1_64   : aliased constant String := "EL1_64";
   String_EL1_3264 : aliased constant String := "EL1_3264";
   MsgPtr_EL1      : constant access constant String := String_EL1'Access;
   MsgPtr_EL1_64   : constant access constant String := String_EL1_64'Access;
   MsgPtr_EL1_3264 : constant access constant String := String_EL1_3264'Access;

   EL2_NONE : constant := 2#0000#; -- EL2 is not implemented.
   EL2_64   : constant := 2#0001#; -- EL2 can be executed in AArch64 state only.
   EL2_3264 : constant := 2#0010#; -- EL2 can be executed in either AArch64 or AArch32 state.

   String_EL2      : aliased constant String := "EL2 Exception level handling";
   String_EL2_NONE : aliased constant String := "EL2_NONE";
   String_EL2_64   : aliased constant String := "EL2_64";
   String_EL2_3264 : aliased constant String := "EL2_3264";
   MsgPtr_EL2      : constant access constant String := String_EL2'Access;
   MsgPtr_EL2_NONE : constant access constant String := String_EL2_NONE'Access;
   MsgPtr_EL2_64   : constant access constant String := String_EL2_64'Access;
   MsgPtr_EL2_3264 : constant access constant String := String_EL2_3264'Access;

   EL3_NONE : constant := 2#0000#; -- EL3 is not implemented.
   EL3_64   : constant := 2#0001#; -- EL3 can be executed in AArch64 state only.
   EL3_3264 : constant := 2#0010#; -- EL3 can be executed in either AArch64 or AArch32 state.

   String_EL3      : aliased constant String := "EL3 Exception level handling";
   String_EL3_NONE : aliased constant String := "EL3_NONE";
   String_EL3_64   : aliased constant String := "EL3_64";
   String_EL3_3264 : aliased constant String := "EL3_3264";
   MsgPtr_EL3      : constant access constant String := String_EL3'Access;
   MsgPtr_EL3_NONE : constant access constant String := String_EL3_NONE'Access;
   MsgPtr_EL3_64   : constant access constant String := String_EL3_64'Access;
   MsgPtr_EL3_3264 : constant access constant String := String_EL3_3264'Access;

   FP_YES           : constant := 2#0000#; -- Floating-point is implemented, and includes support for: • Single-precision and double-precision floating-point types.• Conversions between single-precision and half-precision data types, and double-precision and half-precision data types.
   FP_HALFPRECISION : constant := 2#0001#; -- As for 0b0000, and also includes support for half-precision floating-point arithmetic.
   FP_NONE          : constant := 2#1111#; -- Floating-point is not implemented.

   String_FP               : aliased constant String := "FP Floating-point";
   String_FP_YES           : aliased constant String := "FP_YES";
   String_FP_HALFPRECISION : aliased constant String := "FP_HALFPRECISION";
   String_FP_NONE          : aliased constant String := "FP_NONE";
   MsgPtr_FP               : constant access constant String := String_FP'Access;
   MsgPtr_FP_YES           : constant access constant String := String_FP_YES'Access;
   MsgPtr_FP_HALFPRECISION : constant access constant String := String_FP_HALFPRECISION'Access;
   MsgPtr_FP_NONE          : constant access constant String := String_FP_NONE'Access;

   AdvSIMD_YES           : constant := 2#0000#; -- Advanced SIMD is implemented, including support for the following SISD and SIMD operations: • Integer byte, halfword, word and doubleword element operations.• Single-precision and double-precision floating-point arithmetic.• Conversions between single-precision and half-precision data types, and double-precision and half-precision data types.
   AdvSIMD_HALFPRECISION : constant := 2#0001#; -- As for 0b0000, and also includes support for half-precision floating-point arithmetic.
   AdvSIMD_NONE          : constant := 2#1111#; -- Advanced SIMD is not implemented.

   String_AdvSIMD               : aliased constant String := "AdvSIMD Advanced SIMD";
   String_AdvSIMD_YES           : aliased constant String := "AdvSIMD_YES";
   String_AdvSIMD_HALFPRECISION : aliased constant String := "AdvSIMD_HALFPRECISION";
   String_AdvSIMD_NONE          : aliased constant String := "AdvSIMD_NONE";
   MsgPtr_AdvSIMD               : constant access constant String := String_AdvSIMD'Access;
   MsgPtr_AdvSIMD_YES           : constant access constant String := String_AdvSIMD_YES'Access;
   MsgPtr_AdvSIMD_HALFPRECISION : constant access constant String := String_AdvSIMD_HALFPRECISION'Access;
   MsgPtr_AdvSIMD_NONE          : constant access constant String := String_AdvSIMD_NONE'Access;

   GIC_NONE  : constant := 2#0000#; -- GIC CPU interface system registers not implemented.
   GIC_30_40 : constant := 2#0001#; -- System register interface to versions 3.0 and 4.0 of the GIC CPU interface is supported.
   GIC_41    : constant := 2#0011#; -- System register interface to version 4.1 of the GIC CPU interface is supported.

   String_GIC       : aliased constant String := "GIC System register GIC CPU interface";
   String_GIC_NONE  : aliased constant String := "GIC_NONE";
   String_GIC_30_40 : aliased constant String := "GIC_30_40";
   String_GIC_41    : aliased constant String := "GIC_41";
   MsgPtr_GIC       : constant access constant String := String_GIC'Access;
   MsgPtr_GIC_NONE  : constant access constant String := String_GIC_NONE'Access;
   MsgPtr_GIC_30_40 : constant access constant String := String_GIC_30_40'Access;
   MsgPtr_GIC_41    : constant access constant String := String_GIC_41'Access;

   RAS_NONE : constant := 2#0000#; -- No RAS Extension.
   RAS_YES  : constant := 2#0001#; -- RAS Extension implemented.
   RAS_v1p1 : constant := 2#0010#; -- FEAT_RASv1p1 implemented and, if EL3 is implemented, FEAT_DoubleFault implemented. As 0b0001, and adds support for:• If EL3 is implemented, FEAT_DoubleFault.• Additional ERXMISC<m>_EL1 System registers.• Additional System registers ERXPFGCDN_EL1, ERXPFGCTL_EL1, and ERXPFGF_EL1, and the SCR_EL3.FIEN and HCR_EL2.FIEN trap controls, to support the optional RAS Common Fault Injection Model Extension.

   String_RAS      : aliased constant String := "RAS RAS Extension version";
   String_RAS_NONE : aliased constant String := "RAS_NONE";
   String_RAS_YES  : aliased constant String := "RAS_YES";
   String_RAS_v1p1 : aliased constant String := "RAS_v1p1";
   MsgPtr_RAS      : constant access constant String := String_RAS'Access;
   MsgPtr_RAS_NONE : constant access constant String := String_RAS_NONE'Access;
   MsgPtr_RAS_YES  : constant access constant String := String_RAS_YES'Access;
   MsgPtr_RAS_v1p1 : constant access constant String := String_RAS_v1p1'Access;

   SVE_NONE : constant := 2#0000#; -- SVE architectural state and programmers' model are not implemented.
   SVE_YES  : constant := 2#0001#; -- SVE architectural state and programmers' model are implemented.

   String_SVE      : aliased constant String := "SVE Scalable Vector Extension";
   String_SVE_NONE : aliased constant String := "SVE_NONE";
   String_SVE_YES  : aliased constant String := "SVE_YES";
   MsgPtr_SVE      : constant access constant String := String_SVE'Access;
   MsgPtr_SVE_NONE : constant access constant String := String_SVE_NONE'Access;
   MsgPtr_SVE_YES  : constant access constant String := String_SVE_YES'Access;

   SEL2_NONE : constant := 2#0000#; -- Secure EL2 is not implemented.
   SEL2_YES  : constant := 2#0001#; -- Secure EL2 is implemented.

   String_SEL2      : aliased constant String := "SEL2 Secure EL2";
   String_SEL2_NONE : aliased constant String := "SEL2_NONE";
   String_SEL2_YES  : aliased constant String := "SEL2_YES";
   MsgPtr_SEL2      : constant access constant String := String_SEL2'Access;
   MsgPtr_SEL2_NONE : constant access constant String := String_SEL2_NONE'Access;
   MsgPtr_SEL2_YES  : constant access constant String := String_SEL2_YES'Access;

   MPAM_0 : constant := 2#0000#; -- The major version number of the MPAM extension is 0.
   MPAM_1 : constant := 2#0001#; -- The major version number of the MPAM extension is 1.

   String_MPAM   : aliased constant String := "MPAM MPAM major version number";
   String_MPAM_0 : aliased constant String := "MPAM_0";
   String_MPAM_1 : aliased constant String := "MPAM_1";
   MsgPtr_MPAM   : constant access constant String := String_MPAM'Access;
   MsgPtr_MPAM_0 : constant access constant String := String_MPAM_0'Access;
   MsgPtr_MPAM_1 : constant access constant String := String_MPAM_1'Access;

   AMU_NONE : constant := 2#0000#; -- Activity Monitors Extension is not implemented.
   AMU_v1   : constant := 2#0001#; -- FEAT_AMUv1 is implemented.
   AMU_v1p1 : constant := 2#0010#; -- FEAT_AMUv1p1 is implemented. As 0b0001 and adds support for virtualization of the activity monitor event counters.

   String_AMU      : aliased constant String := "AMU Activity Monitors Extension";
   String_AMU_NONE : aliased constant String := "AMU_NONE";
   String_AMU_v1   : aliased constant String := "AMU_v1";
   String_AMU_v1p1 : aliased constant String := "AMU_v1p1";
   MsgPtr_AMU      : constant access constant String := String_AMU'Access;
   MsgPtr_AMU_NONE : constant access constant String := String_AMU_NONE'Access;
   MsgPtr_AMU_v1   : constant access constant String := String_AMU_v1'Access;
   MsgPtr_AMU_v1p1 : constant access constant String := String_AMU_v1p1'Access;

   DIT_NONE : constant := 2#0000#; -- AArch64 does not guarantee constant execution time of any instructions.
   DIT_YES  : constant := 2#0001#; -- AArch64 provides the PSTATE.DIT mechanism to guarantee constant execution time of certain instructions.

   String_DIT      : aliased constant String := "DIT Data Independent Timing";
   String_DIT_NONE : aliased constant String := "DIT_NONE";
   String_DIT_YES  : aliased constant String := "DIT_YES";
   MsgPtr_DIT      : constant access constant String := String_DIT'Access;
   MsgPtr_DIT_NONE : constant access constant String := String_DIT_NONE'Access;
   MsgPtr_DIT_YES  : constant access constant String := String_DIT_YES'Access;

   RME_NONE : constant := 2#0000#; -- Realm Management Extension not implemented.
   RME_v1   : constant := 2#0001#; -- RMEv1 is implemented.

   String_RME      : aliased constant String := "RME Realm Management Extension";
   String_RME_NONE : aliased constant String := "RME_NONE";
   String_RME_v1   : aliased constant String := "RME_v1";
   MsgPtr_RME      : constant access constant String := String_RME'Access;
   MsgPtr_RME_NONE : constant access constant String := String_RME_NONE'Access;
   MsgPtr_RME_v1   : constant access constant String := String_RME_v1'Access;

   CSV2_NONE   : constant := 2#0000#; -- The implementation does not disclose whether FEAT_CSV2 is implemented.
   CSV2_YES    : constant := 2#0001#; -- FEAT_CSV2 is implemented, but FEAT_CSV2_2 and FEAT_CSV2_3 are not implemented. ID_AA64PFR1_EL1.CSV2_frac determines whether either or both of FEAT_CSV2_1p1 or FEAT_CSV2_1p2 are implemented.
   CSV2_CSV2_2 : constant := 2#0010#; -- FEAT_CSV2_2 is implemented, but FEAT_CSV2_3 is not implemented.
   CSV2_CSV2_3 : constant := 2#0011#; -- FEAT_CSV2_3 is implemented.

   String_CSV2        : aliased constant String := "CSV2 Speculative OOC branch targets";
   String_CSV2_NONE   : aliased constant String := "CSV2_NONE";
   String_CSV2_YES    : aliased constant String := "CSV2_YES";
   String_CSV2_CSV2_2 : aliased constant String := "CSV2_CSV2_2";
   String_CSV2_CSV2_3 : aliased constant String := "CSV2_CSV2_3";
   MsgPtr_CSV2        : constant access constant String := String_CSV2'Access;
   MsgPtr_CSV2_NONE   : constant access constant String := String_CSV2_NONE'Access;
   MsgPtr_CSV2_YES    : constant access constant String := String_CSV2_YES'Access;
   MsgPtr_CSV2_CSV2_2 : constant access constant String := String_CSV2_CSV2_2'Access;
   MsgPtr_CSV2_CSV2_3 : constant access constant String := String_CSV2_CSV2_3'Access;

   CSV3_NONE      : constant := 2#0000#; -- This PE does not disclose whether data loaded under speculation with a permission or domain fault can be used to form an address or generate condition codes or SVE predicate values to be used by other instructions in the speculative sequence.
   CSV3_DATAnADDR : constant := 2#0001#; -- Data loaded under speculation with a permission or domain fault cannot be used to form an address, generate condition codes, or generate SVE predicate values to be used by other instructions in the speculative sequence. The execution timing of any other instructions in the speculative sequence is not a function of the data loaded under speculation.

   String_CSV3           : aliased constant String := "CSV3 Speculative use of faulting data";
   String_CSV3_NONE      : aliased constant String := "CSV3_NONE";
   String_CSV3_DATAnADDR : aliased constant String := "CSV3_DATAnADDR";
   MsgPtr_CSV3           : constant access constant String := String_CSV3'Access;
   MsgPtr_CSV3_NONE      : constant access constant String := String_CSV3_NONE'Access;
   MsgPtr_CSV3_DATAnADDR : constant access constant String := String_CSV3_DATAnADDR'Access;

   type ID_AA64PFR0_EL1_Type is record
      EL0     : Bits_4; -- EL0 Exception level handling.
      EL1     : Bits_4; -- EL1 Exception level handling.
      EL2     : Bits_4; -- EL2 Exception level handling.
      EL3     : Bits_4; -- EL3 Exception level handling.
      FP      : Bits_4; -- Floating-point.
      AdvSIMD : Bits_4; -- Advanced SIMD.
      GIC     : Bits_4; -- System register GIC CPU interface.
      RAS     : Bits_4; -- RAS Extension version.
      SVE     : Bits_4; -- Scalable Vector Extension.
      SEL2    : Bits_4; -- Secure EL2.
      MPAM    : Bits_4; -- Indicates the major version number of support for the MPAM Extension.
      AMU     : Bits_4; -- Indicates support for Activity Monitors Extension.
      DIT     : Bits_4; -- Data Independent Timing.
      RME     : Bits_4; -- Realm Management Extension (RME).
      CSV2    : Bits_4; -- Speculative use of out of context branch targets.
      CSV3    : Bits_4; -- Speculative use of faulting data.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64PFR0_EL1_Type use record
      EL0     at 0 range  0 ..  3;
      EL1     at 0 range  4 ..  7;
      EL2     at 0 range  8 .. 11;
      EL3     at 0 range 12 .. 15;
      FP      at 0 range 16 .. 19;
      AdvSIMD at 0 range 20 .. 23;
      GIC     at 0 range 24 .. 27;
      RAS     at 0 range 28 .. 31;
      SVE     at 0 range 32 .. 35;
      SEL2    at 0 range 36 .. 39;
      MPAM    at 0 range 40 .. 43;
      AMU     at 0 range 44 .. 47;
      DIT     at 0 range 48 .. 51;
      RME     at 0 range 52 .. 55;
      CSV2    at 0 range 56 .. 59;
      CSV3    at 0 range 60 .. 63;
   end record;

   function ID_AA64PFR0_EL1_Read
      return ID_AA64PFR0_EL1_Type
      with Inline => True;

   -- D19.2.70 ID_AA64PFR1_EL1, AArch64 Processor Feature Register 1

   BT_NONE : constant := 2#0000#; -- The Branch Target Identification mechanism is not implemented.
   BT_YES  : constant := 2#0001#; -- The Branch Target Identification mechanism is implemented.

   String_BT      : aliased constant String := "BT Branch Target Identification";
   String_BT_NONE : aliased constant String := "BT_NONE";
   String_BT_YES  : aliased constant String := "BT_YES";
   MsgPtr_BT      : constant access constant String := String_BT'Access;
   MsgPtr_BT_NONE : constant access constant String := String_BT_NONE'Access;
   MsgPtr_BT_YES  : constant access constant String := String_BT_YES'Access;

   SSBS_NONE   : constant := 2#0000#; -- AArch64 provides no mechanism to control the use of Speculative Store Bypassing.
   SSBS_YES    : constant := 2#0001#; -- AArch64 provides the PSTATE.SSBS mechanism to mark regions that are Speculative Store Bypass Safe.
   SSBS_MSRMRS : constant := 2#0010#; -- As 0b0001, and adds the MSR and MRS instructions to directly read and write the PSTATE.SSBS field.

   String_SSBS        : aliased constant String := "SSBS Speculative Store Bypassing";
   String_SSBS_NONE   : aliased constant String := "SSBS_NONE";
   String_SSBS_YES    : aliased constant String := "SSBS_YES";
   String_SSBS_MSRMRS : aliased constant String := "SSBS_MSRMRS";
   MsgPtr_SSBS        : constant access constant String := String_SSBS'Access;
   MsgPtr_SSBS_NONE   : constant access constant String := String_SSBS_NONE'Access;
   MsgPtr_SSBS_YES    : constant access constant String := String_SSBS_YES'Access;
   MsgPtr_SSBS_MSRMRS : constant access constant String := String_SSBS_MSRMRS'Access;

   MTE_NONE      : constant := 2#0000#; -- Memory Tagging Extension is not implemented.
   MTE_INSTR     : constant := 2#0001#; -- Instruction-only Memory Tagging Extension is implemented.
   MTE_MEM       : constant := 2#0010#; -- Full Memory Tagging Extension is implemented.
   MTE_ASYMTAGCF : constant := 2#0011#; -- Memory Tagging Extension is implemented with support for asymmetric Tag Check Fault handling.

   String_MTE           : aliased constant String := "MTE Memory Tagging Extension";
   String_MTE_NONE      : aliased constant String := "MTE_NONE";
   String_MTE_INSTR     : aliased constant String := "MTE_INSTR";
   String_MTE_MEM       : aliased constant String := "MTE_MEM";
   String_MTE_ASYMTAGCF : aliased constant String := "MTE_ASYMTAGCF";
   MsgPtr_MTE           : constant access constant String := String_MTE'Access;
   MsgPtr_MTE_NONE      : constant access constant String := String_MTE_NONE'Access;
   MsgPtr_MTE_INSTR     : constant access constant String := String_MTE_INSTR'Access;
   MsgPtr_MTE_MEM       : constant access constant String := String_MTE_MEM'Access;
   MsgPtr_MTE_ASYMTAGCF : constant access constant String := String_MTE_ASYMTAGCF'Access;

   RAS_frac_RAS      : constant := 2#0000#; -- If ID_AA64PFR0_EL1.RAS == 0b0001, RAS Extension implemented.
   RAS_frac_EXTENDED : constant := 2#0001#; -- If ID_AA64PFR0_EL1.RAS == 0b0001, as 0b0000 and adds support for:• Additional ERXMISC<m>_EL1 System registers.• Additional System registers ERXPFGCDN_EL1, ERXPFGCTL_EL1, and ERXPFGF_EL1, and the SCR_EL3.FIEN and HCR_EL2.FIEN trap controls, to support the optional RAS Common Fault Injection Model Extension.

   String_RAS_frac          : aliased constant String := "RAS_frac Extension fractional field";
   String_RAS_frac_RAS      : aliased constant String := "RAS_frac_RAS";
   String_RAS_frac_EXTENDED : aliased constant String := "RAS_frac_EXTENDED";
   MsgPtr_RAS_frac          : constant access constant String := String_RAS_frac'Access;
   MsgPtr_RAS_frac_RAS      : constant access constant String := String_RAS_frac_RAS'Access;
   MsgPtr_RAS_frac_EXTENDED : constant access constant String := String_RAS_frac_EXTENDED'Access;

   MPAM_frac_0 : constant := 2#0000#; -- The minor version number of the MPAM extension is 0.
   MPAM_frac_1 : constant := 2#0001#; -- The minor version number of the MPAM extension is 1.

   String_MPAM_frac   : aliased constant String := "MPAM_frac MPAM major version number";
   String_MPAM_frac_0 : aliased constant String := "MPAM_frac_0";
   String_MPAM_frac_1 : aliased constant String := "MPAM_frac_1";
   MsgPtr_MPAM_frac   : constant access constant String := String_MPAM_frac'Access;
   MsgPtr_MPAM_frac_0 : constant access constant String := String_MPAM_frac_0'Access;
   MsgPtr_MPAM_frac_1 : constant access constant String := String_MPAM_frac_1'Access;

   SME_NONE    : constant := 2#0000#; -- SME architectural state and programmers' model are not implemented.
   SME_YES     : constant := 2#0001#; -- SME architectural state and programmers' model are implemented.
   SME_SME2ZT0 : constant := 2#0010#; -- As 0b0001, plus the SME2 ZT0 register.

   String_SME         : aliased constant String := "SME Scalable Matrix Extension";
   String_SME_NONE    : aliased constant String := "SME_NONE";
   String_SME_YES     : aliased constant String := "SME_YES";
   String_SME_SME2ZT0 : aliased constant String := "SME_SME2ZT0";
   MsgPtr_SME         : constant access constant String := String_SME'Access;
   MsgPtr_SME_NONE    : constant access constant String := String_SME_NONE'Access;
   MsgPtr_SME_YES     : constant access constant String := String_SME_YES'Access;
   MsgPtr_SME_SME2ZT0 : constant access constant String := String_SME_SME2ZT0'Access;

   RNDR_trap_NONE : constant := 2#0000#; -- Trapping of RNDR and RNDRRS to EL3 is not supported.
   RNDR_trap_YES  : constant := 2#0001#; -- Trapping of RNDR and RNDRRS to EL3 is supported.

   String_RNDR_trap      : aliased constant String := "RNDR_trap Random Number trap";
   String_RNDR_trap_NONE : aliased constant String := "RNDR_trap_NONE";
   String_RNDR_trap_YES  : aliased constant String := "RNDR_trap_YES";
   MsgPtr_RNDR_trap      : constant access constant String := String_RNDR_trap'Access;
   MsgPtr_RNDR_trap_NONE : constant access constant String := String_RNDR_trap_NONE'Access;
   MsgPtr_RNDR_trap_YES  : constant access constant String := String_RNDR_trap_YES'Access;

   CSV2_frac_NONE : constant := 2#0000#; -- Either ID_AA64PFR0_EL1.CSV2 is not 0b0001, or the implementation does not disclose whether FEAT_CSV2_1p1 is implemented. FEAT_CSV2_1p2 is not implemented.
   CSV2_frac_1p1  : constant := 2#0001#; -- FEAT_CSV2_1p1 is implemented, but FEAT_CSV2_1p2 is not implemented.
   CSV2_frac_1p2  : constant := 2#0010#; -- FEAT_CSV2_1p2 is implemented.

   String_CSV2_frac      : aliased constant String := "CSV2_frac CSV2 fractional";
   String_CSV2_frac_NONE : aliased constant String := "CSV2_frac_NONE";
   String_CSV2_frac_1p1  : aliased constant String := "CSV2_frac_1p1";
   String_CSV2_frac_1p2  : aliased constant String := "CSV2_frac_1p2";
   MsgPtr_CSV2_frac      : constant access constant String := String_CSV2_frac'Access;
   MsgPtr_CSV2_frac_NONE : constant access constant String := String_CSV2_frac_NONE'Access;
   MsgPtr_CSV2_frac_1p1  : constant access constant String := String_CSV2_frac_1p1'Access;
   MsgPtr_CSV2_frac_1p2  : constant access constant String := String_CSV2_frac_1p2'Access;

   NMI_NONE : constant := 2#0000#; -- SCTLR_ELx.{SPINTMASK, NMI} and PSTATE.ALLINT with its associated instructions are not supported.
   NMI_YES  : constant := 2#0001#; -- SCTLR_ELx.{SPINTMASK, NMI} and PSTATE.ALLINT with its associated instructions are supported.

   String_NMI      : aliased constant String := "NMI Non-maskable Interrupt";
   String_NMI_NONE : aliased constant String := "NMI_NONE";
   String_NMI_YES  : aliased constant String := "NMI_YES";
   MsgPtr_NMI      : constant access constant String := String_NMI'Access;
   MsgPtr_NMI_NONE : constant access constant String := String_NMI_NONE'Access;
   MsgPtr_NMI_YES  : constant access constant String := String_NMI_YES'Access;

   type ID_AA64PFR1_EL1_Type is record
      BT        : Bits_4;  -- Branch Target Identification mechanism support in AArch64 state.
      SSBS      : Bits_4;  -- Speculative Store Bypassing controls in AArch64 state.
      MTE       : Bits_4;  -- Support for the Memory Tagging Extension.
      RAS_frac  : Bits_4;  -- RAS Extension fractional field.
      MPAM_frac : Bits_4;  -- Indicates the minor version number of support for the MPAM Extension.
      Reserved1 : Bits_4;
      SME       : Bits_4;  -- Scalable Matrix Extension.
      RNDR_trap : Bits_4;  -- Random Number trap to EL3 field.
      CSV2_frac : Bits_4;  -- CSV2 fractional field.
      NMI       : Bits_4;  -- Non-maskable Interrupt.
      Reserved2 : Bits_24;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ID_AA64PFR1_EL1_Type use record
      BT        at 0 range  0 ..  3;
      SSBS      at 0 range  4 ..  7;
      MTE       at 0 range  8 .. 11;
      RAS_frac  at 0 range 12 .. 15;
      MPAM_frac at 0 range 16 .. 19;
      Reserved1 at 0 range 20 .. 23;
      SME       at 0 range 24 .. 27;
      RNDR_trap at 0 range 28 .. 31;
      CSV2_frac at 0 range 32 .. 35;
      NMI       at 0 range 36 .. 39;
      Reserved2 at 0 range 40 .. 63;
   end record;

   function ID_AA64PFR1_EL1_Read
      return ID_AA64PFR1_EL1_Type
      with Inline => True;

   -- Maximum string length of the messages above, useful for aligned printout

   ID_AA64PFRx_EL1_Max_String_Length : constant := 37;

   -- D19.2.71 ID_AA64PFR2_EL1, AArch64 Processor Feature Register 2
   -- Reserved for future expansion of information about implemented PE features in AArch64 state.

   -- D19.2.72 ID_AA64SMFR0_EL1, SME Feature ID register 0
   -- D19.2.73 ID_AA64ZFR0_EL1, SVE Feature ID register 0
   -- D19.2.74 ID_AFR0_EL1, AArch32 Auxiliary Feature Register 0
   -- D19.2.75 ID_DFR0_EL1, AArch32 Debug Feature Register 0
   -- D19.2.76 ID_DFR1_EL1, Debug Feature Register 1
   -- D19.2.77 ID_ISAR0_EL1, AArch32 Instruction Set Attribute Register 0
   -- D19.2.78 ID_ISAR1_EL1, AArch32 Instruction Set Attribute Register 1
   -- D19.2.79 ID_ISAR2_EL1, AArch32 Instruction Set Attribute Register 2
   -- D19.2.80 ID_ISAR3_EL1, AArch32 Instruction Set Attribute Register 3
   -- D19.2.81 ID_ISAR4_EL1, AArch32 Instruction Set Attribute Register 4
   -- D19.2.82 ID_ISAR5_EL1, AArch32 Instruction Set Attribute Register 5
   -- D19.2.83 ID_ISAR6_EL1, AArch32 Instruction Set Attribute Register 6
   -- D19.2.84 ID_MMFR0_EL1, AArch32 Memory Model Feature Register 0
   -- D19.2.85 ID_MMFR1_EL1, AArch32 Memory Model Feature Register 1
   -- D19.2.86 ID_MMFR2_EL1, AArch32 Memory Model Feature Register 2
   -- D19.2.87 ID_MMFR3_EL1, AArch32 Memory Model Feature Register 3
   -- D19.2.88 ID_MMFR4_EL1, AArch32 Memory Model Feature Register 4
   -- D19.2.89 ID_MMFR5_EL1, AArch32 Memory Model Feature Register 5
   -- D19.2.90 ID_PFR0_EL1, AArch32 Processor Feature Register 0
   -- D19.2.91 ID_PFR1_EL1, AArch32 Processor Feature Register 1
   -- D19.2.92 ID_PFR2_EL1, AArch32 Processor Feature Register 2
   -- D19.2.93 IFSR32_EL2, Instruction Fault Status Register (EL2)

   -- D19.2.94 ISR_EL1, Interrupt Status Register

   type ISR_EL1_Type is record
      Reserved1 : Bits_6;
      F         : Boolean; -- FIQ pending bit.
      I         : Boolean; -- IRQ pending bit.
      A         : Boolean; -- SError interrupt pending bit.
      F_S       : Boolean; -- FIQ with Superpriority pending bit.
      I_S       : Boolean; -- IRQ with Superpriority pending bit.
      Reserved2 : Bits_53;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for ISR_EL1_Type use record
      Reserved1 at 0 range  0 ..  5;
      F         at 0 range  6 ..  6;
      I         at 0 range  7 ..  7;
      A         at 0 range  8 ..  8;
      F_S       at 0 range  9 ..  9;
      I_S       at 0 range 10 .. 10;
      Reserved2 at 0 range 11 .. 63;
   end record;

   function ISR_EL1_Read
      return ISR_EL1_Type
      with Inline => True;

   -- D19.2.95 LORC_EL1, LORegion Control (EL1)
   -- D19.2.96 LOREA_EL1, LORegion End Address (EL1)
   -- D19.2.97 LORID_EL1, LORegionID (EL1)
   -- D19.2.98 LORN_EL1, LORegion Number (EL1)
   -- D19.2.99 LORSA_EL1, LORegion Start Address (EL1)

   -- D19.2.100 MAIR_EL1, Memory Attribute Indirection Register (EL1)
   -- D19.2.101 MAIR_EL2, Memory Attribute Indirection Register (EL2)
   -- D19.2.102 MAIR_EL3, Memory Attribute Indirection Register (EL3)

   type MAIR_Array_Type is array (0 .. 7) of Memory_Attribute_Type
      with Pack => True,
           Size => 64;

   type MAIR_ELx_Type is record
      Attr : MAIR_Array_Type;
   end record
      with Size => 64;

   function MAIR_EL1_Read
      return MAIR_ELx_Type
      with Inline => True;
   procedure MAIR_EL1_Write
      (Value : in MAIR_ELx_Type)
      with Inline => True;
   function MAIR_EL2_Read
      return MAIR_ELx_Type
      with Inline => True;
   procedure MAIR_EL2_Write
      (Value : in MAIR_ELx_Type)
      with Inline => True;
   function MAIR_EL3_Read
      return MAIR_ELx_Type
      with Inline => True;
   procedure MAIR_EL3_Write
      (Value : in MAIR_ELx_Type)
      with Inline => True;

   -- D19.2.103 MIDR_EL1, Main ID Register

   type Architecture_Type is record
      CODE        : Bits_4;
      DESCRIPTION : access constant String;
   end record;

   Architecture_Armv4    : aliased constant String := "Armv4";
   Architecture_Armv4T   : aliased constant String := "Armv4T";
   Architecture_Armv5    : aliased constant String := "Armv5";
   Architecture_Armv5T   : aliased constant String := "Armv5T";
   Architecture_Armv5TE  : aliased constant String := "Armv5TE";
   Architecture_Armv5TEJ : aliased constant String := "Armv5TEJ";
   Architecture_Armv6    : aliased constant String := "Armv6";
   Architecture_ID       : aliased constant String := "ID_*";

   Architectures : constant array (1 .. 8) of Architecture_Type := [
      (2#0001#, Architecture_Armv4'Access),
      (2#0010#, Architecture_Armv4T'Access),
      (2#0011#, Architecture_Armv5'Access),
      (2#0100#, Architecture_Armv5T'Access),
      (2#0101#, Architecture_Armv5TE'Access),
      (2#0110#, Architecture_Armv5TEJ'Access),
      (2#0111#, Architecture_Armv6'Access),
      (2#1111#, Architecture_ID'Access)
      ];

   type Implementer_Type is record
      CODE        : Bits_8;
      DESCRIPTION : access constant String;
   end record;

   Implementer_Software  : aliased constant String := "Software";
   Implementer_Arm       : aliased constant String := "Arm Limited";
   Implementer_Broadcom  : aliased constant String := "Broadcom Corporation";
   Implementer_Cavium    : aliased constant String := "Cavium Inc";
   Implementer_DEC       : aliased constant String := "Digital Equipment Corporation";
   Implementer_Fujitsu   : aliased constant String := "Fujitsu Ltd";
   Implementer_Infineon  : aliased constant String := "Infineon Technologies AG";
   Implementer_Freescale : aliased constant String := "Motorola or Freescale Semiconductor Inc";
   Implementer_NVIDIA    : aliased constant String := "NVIDIA Corporation";
   Implementer_AMCC      : aliased constant String := "Applied Micro Circuits Corporation";
   Implementer_Qualcomm  : aliased constant String := "Qualcomm Inc";
   Implementer_Marvell   : aliased constant String := "Marvell International Ltd";
   Implementer_Intel     : aliased constant String := "Intel Corporation";
   Implementer_Ampere    : aliased constant String := "Ampere Computing";

   Implementers : constant array (1 .. 14) of Implementer_Type := [
      (16#00#, Implementer_Software'Access),
      (16#41#, Implementer_Arm'Access),
      (16#42#, Implementer_Broadcom'Access),
      (16#43#, Implementer_Cavium'Access),
      (16#44#, Implementer_DEC'Access),
      (16#46#, Implementer_Fujitsu'Access),
      (16#49#, Implementer_Infineon'Access),
      (16#4D#, Implementer_Freescale'Access),
      (16#4E#, Implementer_NVIDIA'Access),
      (16#50#, Implementer_AMCC'Access),
      (16#51#, Implementer_Qualcomm'Access),
      (16#56#, Implementer_Marvell'Access),
      (16#69#, Implementer_Intel'Access),
      (16#C0#, Implementer_Ampere'Access)
      ];

   type MIDR_EL1_Type is record
      Revision     : Bits_4;  -- Revision number for the device.
      PartNum      : Bits_12; -- Primary Part Number for the device.
      Architecture : Bits_4;  -- Architecture version.
      Variant      : Bits_4;  -- Variant number.
      Implementer  : Bits_8;  -- The Implementer code.
      Reserved     : Bits_32;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for MIDR_EL1_Type use record
      Revision     at 0 range  0 ..  3;
      PartNum      at 0 range  4 .. 15;
      Architecture at 0 range 16 .. 19;
      Variant      at 0 range 20 .. 23;
      Implementer  at 0 range 24 .. 31;
      Reserved     at 0 range 32 .. 63;
   end record;

   function MIDR_EL1_Read
      return MIDR_EL1_Type
      with Inline => True;

   -- D19.2.104 MPIDR_EL1, Multiprocessor Affinity Register

   type MPIDR_EL1_Type is record
      Aff0      : Unsigned_8; -- Affinity level 0.
      Aff1      : Unsigned_8; -- Affinity level 1.
      Aff2      : Unsigned_8; -- Affinity level 2.
      MT        : Boolean;    -- Indicates whether the lowest level of affinity consists of logical PEs that are implemented using a multithreading type approach. See the description of Aff0 for more information about affinity levels.
      Reserved1 : Bits_5;
      U         : Boolean;    -- Indicates a Uniprocessor system, as distinct from PE 0 in a multiprocessor system.
      Reserved2 : Bits_1;
      Aff3      : Unsigned_8; -- Affinity level 3.
      Reserved3 : Bits_24;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for MPIDR_EL1_Type use record
      Aff0      at 0 range  0 ..  7;
      Aff1      at 0 range  8 .. 15;
      Aff2      at 0 range 16 .. 23;
      MT        at 0 range 24 .. 24;
      Reserved1 at 0 range 25 .. 29;
      U         at 0 range 30 .. 30;
      Reserved2 at 0 range 31 .. 31;
      Aff3      at 0 range 32 .. 39;
      Reserved3 at 0 range 40 .. 63;
   end record;

   function MPIDR_EL1_Read
      return MPIDR_EL1_Type
      with Inline => True;

   -- D19.2.105 MVFR0_EL1, AArch32 Media and VFP Feature Register 0
   -- D19.2.106 MVFR1_EL1, AArch32 Media and VFP Feature Register 1
   -- D19.2.107 MVFR2_EL1, AArch32 Media and VFP Feature Register 2
   -- D19.2.108 PAR_EL1, Physical Address Register
   -- D19.2.109 REVIDR_EL1, Revision ID Register
   -- D19.2.110 RGSR_EL1, Random Allocation Tag Seed Register.

   -- D19.2.111 RMR_EL1, Reset Management Register (EL1)
   -- D19.2.112 RMR_EL2, Reset Management Register (EL2)
   -- D19.2.113 RMR_EL3, Reset Management Register (EL3)

   type RMR_EL1_Type is record
      AA64     : Boolean := False; -- When EL1 can use AArch32, determines which Execution state the PE boots into after a Warm reset:
      RR       : Boolean := False; -- Reset Request.
      Reserved : Bits_62 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for RMR_EL1_Type use record
      AA64     at 0 range 0 ..  0;
      RR       at 0 range 1 ..  1;
      Reserved at 0 range 2 .. 63;
   end record;

   function RMR_EL1_Read
      return RMR_EL1_Type
      with Inline => True;
   procedure RMR_EL1_Write
      (Value : in RMR_EL1_Type)
      with Inline => True;

   type RMR_EL2_Type is record
      AA64     : Boolean := False; -- When EL2 can use AArch32, determines which Execution state the PE boots into after a Warm reset:
      RR       : Boolean := False; -- Reset Request.
      Reserved : Bits_62 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for RMR_EL2_Type use record
      AA64     at 0 range 0 ..  0;
      RR       at 0 range 1 ..  1;
      Reserved at 0 range 2 .. 63;
   end record;

   function RMR_EL2_Read
      return RMR_EL2_Type
      with Inline => True;
   procedure RMR_EL2_Write
      (Value : in RMR_EL2_Type)
      with Inline => True;

   type RMR_EL3_Type is record
      AA64     : Boolean := False; -- When EL3 can use AArch32, determines which Execution state the PE boots into after a Warm reset:
      RR       : Boolean := False; -- Reset Request.
      Reserved : Bits_62 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for RMR_EL3_Type use record
      AA64     at 0 range 0 ..  0;
      RR       at 0 range 1 ..  1;
      Reserved at 0 range 2 .. 63;
   end record;

   function RMR_EL3_Read
      return RMR_EL3_Type
      with Inline => True;
   procedure RMR_EL3_Write
      (Value : in RMR_EL3_Type)
      with Inline => True;

   -- D19.2.114 RNDR, Random Number
   -- D19.2.115 RNDRRS, Reseeded Random Number
   -- D19.2.116 RVBAR_EL1, Reset Vector Base Address Register (if EL2 and EL3 not implemented)
   -- D19.2.117 RVBAR_EL2, Reset Vector Base Address Register (if EL3 not implemented)
   -- D19.2.118 RVBAR_EL3, Reset Vector Base Address Register (if EL3 implemented)

   -- D19.2.119 S3_<op1>_<Cn>_<Cm>_<op2>, IMPLEMENTATION DEFINED registers

#if CPUECTLR_EL1
   -- CPU Extended Control Register, EL1

   CPURETCTL_NONE : constant := 2#000#; -- Disable the retention circuit. This is the reset value.
   CPURETCTL_2    : constant := 2#001#; -- 2 Architectural Timer ticks are required before retention entry.
   CPURETCTL_8    : constant := 2#010#; -- 8 Architectural Timer ticks are required before retention entry.
   CPURETCTL_32   : constant := 2#011#; -- 32 Architectural Timer ticks are required before retention entry.
   CPURETCTL_64   : constant := 2#100#; -- 64 Architectural Timer ticks are required before retention entry.
   CPURETCTL_128  : constant := 2#101#; -- 128 Architectural Timer ticks are required before retention entry.
   CPURETCTL_256  : constant := 2#110#; -- 256 Architectural Timer ticks are required before retention entry.
   CPURETCTL_512  : constant := 2#111#; -- 512 Architectural Timer ticks are required before retention entry.

   FPRETCTL_NONE : constant := 2#000#; -- Disable the retention circuit. This is the reset value.
   FPRETCTL_2    : constant := 2#001#; -- 2 Architectural Timer ticks are required before retention entry.
   FPRETCTL_8    : constant := 2#010#; -- 8 Architectural Timer ticks are required before retention entry.
   FPRETCTL_32   : constant := 2#011#; -- 32 Architectural Timer ticks are required before retention entry.
   FPRETCTL_64   : constant := 2#100#; -- 64 Architectural Timer ticks are required before retention entry.
   FPRETCTL_128  : constant := 2#101#; -- 128 Architectural Timer ticks are required before retention entry.
   FPRETCTL_256  : constant := 2#110#; -- 256 Architectural Timer ticks are required before retention entry.
   FPRETCTL_512  : constant := 2#111#; -- 512 Architectural Timer ticks are required before retention entry.

   type CPUECTLR_EL1_Type is record
      CPURETCTL : Bits_3  := CPURETCTL_NONE; -- CPU retention control.
      FPRETCTL  : Bits_3  := FPRETCTL_NONE;  -- Advanced SIMD and Floating-point retention control.
      SMPEN     : Boolean := False;          -- Enable hardware management of data coherency with other cores in the cluster.
      Reserved  : Bits_57 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CPUECTLR_EL1_Type use record
      CPURETCTL at 0 range 0 ..  2;
      FPRETCTL  at 0 range 3 ..  5;
      SMPEN     at 0 range 6 ..  6;
      Reserved  at 0 range 7 .. 63;
   end record;

   function CPUECTLR_EL1_Read
      return CPUECTLR_EL1_Type
      with Inline => True;
   procedure CPUECTLR_EL1_Write
      (Value : in CPUECTLR_EL1_Type)
      with Inline => True;
#end if;

   -- D19.2.120 SCR_EL3, Secure Configuration Register

   type Non_Secure_Type is record
      NS  : Bits_1;
      NSE : Bits_1;
   end record;

   Non_Secure_Secure    : constant Non_Secure_Type := (0, 0); -- Secure.
   Non_Secure_NonSecure : constant Non_Secure_Type := (0, 1); -- Non-secure.
   Non_Secure_Reserved  : constant Non_Secure_Type := (1, 0); -- Reserved.
   Non_Secure_Realm     : constant Non_Secure_Type := (1, 1); -- Realm.

   type SCR_EL3_Type is record
      NS        : Bits_1;           -- Non-secure bit.
      IRQ       : Boolean;          -- Physical IRQ Routing.
      FIQ       : Boolean;          -- Physical FIQ Routing.
      EA        : Boolean;          -- External Abort and SError interrupt routing.
      Reserved1 : Bits_2  := 2#11#;
      Reserved2 : Bits_1  := 0;
      SMD       : Boolean;          -- Secure Monitor Call disable.
      HCE       : Boolean;          -- Hypervisor Call instruction enable.
      SIF       : Boolean;          -- Secure instruction fetch.
      RW        : Boolean;          -- Execution state control for lower Exception levels.
      ST        : Boolean;          -- Traps Secure EL1 accesses to the Counter-timer Physical Secure timer registers to EL3, from AArch64 state only, reported using an ESR_ELx.EC value of 0x18.
      TWI       : Boolean;          -- Traps EL2, EL1, and EL0 execution of WFI instructions to EL3, from any Security state and both Execution states, reported using an ESR_ELx.EC value of 0x01 .
      TWE       : Boolean;          -- Traps EL2, EL1, and EL0 execution of WFE instructions to EL3, from any Security state and both Execution states, reported using an ESR_ELx.EC value of 0x01 .
      TLOR      : Boolean;          -- Trap LOR registers.
      TERR      : Boolean;          -- Trap accesses of error record registers.
      APK       : Boolean;          -- Trap registers holding "key" values for Pointer Authentication.
      API       : Boolean;          -- Controls the use of the following instructions related to Pointer Authentication.
      EEL2      : Boolean;          -- Secure EL2 Enable.
      EASE      : Boolean;          -- External aborts to SError interrupt vector.
      NMEA      : Boolean;          -- Non-maskable External Aborts.
      FIEN      : Boolean;          -- Fault Injection enable.
      Reserved3 : Bits_3  := 0;
      EnSCXT    : Boolean;          -- Enables access to the SCXTNUM_EL2, SCXTNUM_EL1, and SCXTNUM_EL0 registers.
      ATA       : Boolean;          -- Allocation Tag Access.
      FGTEn     : Boolean;          -- Fine-Grained Traps Enable.
      ECVEn     : Boolean;          -- ECV Enable.
      TWEDEn    : Boolean;          -- TWE Delay Enable.
      TWEDEL    : Bits_4;           -- TWE Delay.
      TME       : Boolean;          -- Enables access to the TSTART, TCOMMIT, TTEST and TCANCEL instructions at EL0, EL1 and EL2.
      AMVOFFEN  : Boolean;          -- Activity Monitors Virtual Offsets Enable.
      EnAS0     : Boolean;          -- Traps execution of an ST64BV0 instruction at EL0, EL1, or EL2 to EL3.
      ADEn      : Boolean;          -- Enables access to the ACCDATA_EL1 register at EL1 and EL2.
      HXEn      : Boolean;          -- Enables access to the HCRX_EL2 register at EL2 from EL3.
      Reserved4 : Bits_1  := 0;
      TRNDR     : Boolean;          -- Controls trapping of reads of RNDR and RNDRRS.
      EnTP2     : Boolean;          -- Traps instructions executed at EL2, EL1, and EL0 that access TPIDR2_EL0 to EL3.
      Reserved5 : Bits_1  := 0;
      TCR2En    : Boolean;          -- TCR2_ELx register trap control.
      SCTLR2En  : Boolean;          -- SCTLR2_ELx register trap control.
      Reserved6 : Bits_3  := 0;
      GPF       : Boolean;          -- Controls the reporting of Granule protection faults at EL0, EL1 and EL2.
      MECEn     : Boolean;          -- Enables access to the following EL2 MECID registers, from EL2: ...
      Reserved7 : Bits_12 := 0;
      NSE       : Bits_1;           -- This field, evaluated with SCR_EL3.NS, selects the Security state of EL2 and lower Exception levels.
      Reserved8 : Bits_1  := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for SCR_EL3_Type use record
      NS        at 0 range  0 ..  0;
      IRQ       at 0 range  1 ..  1;
      FIQ       at 0 range  2 ..  2;
      EA        at 0 range  3 ..  3;
      Reserved1 at 0 range  4 ..  5;
      Reserved2 at 0 range  6 ..  6;
      SMD       at 0 range  7 ..  7;
      HCE       at 0 range  8 ..  8;
      SIF       at 0 range  9 ..  9;
      RW        at 0 range 10 .. 10;
      ST        at 0 range 11 .. 11;
      TWI       at 0 range 12 .. 12;
      TWE       at 0 range 13 .. 13;
      TLOR      at 0 range 14 .. 14;
      TERR      at 0 range 15 .. 15;
      APK       at 0 range 16 .. 16;
      API       at 0 range 17 .. 17;
      EEL2      at 0 range 18 .. 18;
      EASE      at 0 range 19 .. 19;
      NMEA      at 0 range 20 .. 20;
      FIEN      at 0 range 21 .. 21;
      Reserved3 at 0 range 22 .. 24;
      EnSCXT    at 0 range 25 .. 25;
      ATA       at 0 range 26 .. 26;
      FGTEn     at 0 range 27 .. 27;
      ECVEn     at 0 range 28 .. 28;
      TWEDEn    at 0 range 29 .. 29;
      TWEDEL    at 0 range 30 .. 33;
      TME       at 0 range 34 .. 34;
      AMVOFFEN  at 0 range 35 .. 35;
      EnAS0     at 0 range 36 .. 36;
      ADEn      at 0 range 37 .. 37;
      HXEn      at 0 range 38 .. 38;
      Reserved4 at 0 range 39 .. 39;
      TRNDR     at 0 range 40 .. 40;
      EnTP2     at 0 range 41 .. 41;
      Reserved5 at 0 range 42 .. 42;
      TCR2En    at 0 range 43 .. 43;
      SCTLR2En  at 0 range 44 .. 44;
      Reserved6 at 0 range 45 .. 47;
      GPF       at 0 range 48 .. 48;
      MECEn     at 0 range 49 .. 49;
      Reserved7 at 0 range 50 .. 61;
      NSE       at 0 range 62 .. 62;
      Reserved8 at 0 range 63 .. 63;
   end record;

   function SCR_EL3_Read
      return SCR_EL3_Type
      with Inline => True;
   procedure SCR_EL3_Write
      (Value : in SCR_EL3_Type)
      with Inline => True;

   -- D19.2.121 SCTLR2_EL1, System Control Register (EL1)
   -- D19.2.122 SCTLR2_EL2, System Control Register (EL2)
   -- D19.2.123 SCTLR2_EL3, System Control Register (EL3)

   -- D19.2.124 SCTLR_EL1, System Control Register (EL1)

   E0E_LE : constant := 0; -- Explicit data accesses at EL0 are little-endian.
   E0E_BE : constant := 1; -- Explicit data accesses at EL0 are big-endian.

   EE_LE : constant := 0; -- Little-endian.
   EE_BE : constant := 1; -- Big-endian.

   TCF_NONE     : constant := 2#00#; -- Tag Check Faults have no effect on the PE.
   TCF_SYN      : constant := 2#01#; -- Tag Check Faults cause a synchronous exception.
   TCF_ACC      : constant := 2#10#; -- Tag Check Faults are asynchronously accumulated.
   TCF_RSYNWACC : constant := 2#11#; -- [FEAT_MTE3] Tag Check Faults cause a syn exc on reads, and are asyn acc on writes.

   DSSBS_0 : constant := 0; -- PSTATE.SSBS is set to 0 on an exception to EL1.
   DSSBS_1 : constant := 1; -- PSTATE.SSBS is set to 1 on an exception to EL1.

   type SCTLR_EL1_Type is record
      M          : Boolean;      -- MMU enable for EL1&0 stage 1 address translation.
      A          : Boolean;      -- Alignment check enable.
      C          : Boolean;      -- Stage 1 Cacheability control, for data accesses.
      SA         : Boolean;      -- SP Alignment check enable.
      SA0        : Boolean;      -- SP Alignment check enable for EL0.
      CP15BEN    : Boolean;      -- System instruction memory barrier enable.
      nAA        : Boolean;      -- Non-aligned access.
      ITD        : Boolean;      -- IT disable.
      SED        : Boolean;      -- SETEND instruction disable.
      UMA        : Boolean;      -- User Mask Access.
      EnRCTX     : Boolean;      -- Enable EL0 access to the following System instructions:• CFPRCTX, DVPRCTX and CPPRCTX instructions.• CFP RCTX, DVP RCTX and CPP RCTX instructions.
      EOS        : Boolean;      -- Exception Exit is Context Synchronizing.
      I          : Boolean;      -- Stage 1 instruction access Cacheability control, for accesses at EL0 and EL1:
      EnDB       : Boolean;      -- Controls enabling of pointer authentication (using the APDBKey_EL1 key) of instruction addresses in the EL1&0 translation regime.
      DZE        : Boolean;      -- Traps EL0 execution of DC ZVA instructions to EL1, or to EL2 when it is implemented and enabled for the current Security state and HCR_EL2.TGE is 1, from AArch64 state only, reported using an ESR_ELx.EC value of 0x18.
      UCT        : Boolean;      -- Traps EL0 accesses to the CTR_EL0 to EL1, or to EL2 when it is implemented and enabled for the current Security state and HCR_EL2.TGE is 1, from AArch64 state only, reported using an ESR_ELx.EC value of 0x18.
      nTWI       : Boolean;      -- Traps EL0 execution of WFI instructions to EL1, or to EL2 when it is implemented and enabled for the current Security state and HCR_EL2.TGE is 1, from both Execution states, reported using an ESR_ELx.EC value of 0x01.
      Reserved1  : Bits_1  := 0;
      nTWE       : Boolean;      -- Traps EL0 execution of WFE instructions to EL1, or to EL2 when it is implemented and enabled for the current Security state and HCR_EL2.TGE is 1, from both Execution states, reported using an ESR_ELx.EC value of 0x01.
      WXN        : Boolean;      -- Write permission implies Execute Never (XN).
      TSCXT      : Boolean;      -- Trap EL0 Access to the SCXTNUM_EL0 register, when EL0 is using AArch64.
      IESB       : Boolean;      -- Implicit Error Synchronization event enable.
      EIS        : Boolean;      -- Exception Entry is Context Synchronizing.
      SPAN       : Boolean;      -- Set Privileged Access Never, on taking an exception to EL1.
      E0E        : Bits_1;       -- Endianness of data accesses at EL0.
      EE         : Bits_1;       -- Endianness of data accesses at EL1, and stage 1 translation table walks in the EL1&0 translation regime.
      UCI        : Boolean;      -- Enables EL0 access to the DC CVAU, DC CIVAC, DC CVAC and IC IVAU instrs in AArch64 state.
      EnDA       : Boolean;      -- Controls enabling of pointer authentication (using the APDAKey_EL1 key) of instruction addresses in the EL1&0 translation regime.
      nTLSMD     : Boolean;      -- No Trap Load Multiple and Store Multiple to Device-nGRE/Device-nGnRE/Device-nGnRnE memory.
      LSMAOE     : Boolean;      -- Load Multiple and Store Multiple Atomicity and Ordering Enable.
      EnIB       : Boolean;      -- Controls enabling of pointer authentication (using the APIBKey_EL1 key) of instruction addresses in the EL1&0 translation regime.
      EnIA       : Boolean;      -- Controls enabling of pointer authentication (using the APIAKey_EL1 key) of instruction addresses in the EL1&0 translation regime.
      CMOW       : Boolean;      -- Controls cache maintenance instruction permission for the following instructions executed at EL0.• IC IVAU, DC CIVAC, DC CIGDVAC and DC CIGVAC.
      MSCEn      : Boolean;      -- Memory Copy and Memory Set instructions Enable.
      Reserved2  : Bits_1  := 0;
      BT0        : Boolean;      -- PAC Branch Type compatibility at EL0.
      BT1        : Boolean;      -- PAC Branch Type compatibility at EL1.
      ITFSB      : Boolean;      -- When synchronous exceptions are not being generated by Tag Check Faults, this field controls whether on exception entry into EL1, all Tag Check Faults due to instructions executed before exception entry, that are reported asynchronously, are synchronized into TFSRE0_EL1 and TFSR_EL1 registers.
      TCF0       : Bits_2;       -- Tag Check Fault in EL0.
      TCF        : Bits_2;       -- Tag Check Fault in EL1.
      ATA0       : Boolean;      -- Allocation Tag Access in EL0.
      ATA        : Boolean;      -- Allocation Tag Access in EL1.
      DSSBS      : Bits_1;       -- Default PSTATE.SSBS value on Exception Entry.
      TWEDEn     : Boolean;      -- TWE Delay Enable.
      TWEDEL     : Bits_4;       -- TWE Delay.
      TMT0       : Boolean;      -- Forces a trivial implementation of the Transactional Memory Extension at EL0.
      TMT        : Boolean;      -- Forces a trivial implementation of the Transactional Memory Extension at EL1.
      TME0       : Boolean;      -- Enables the Transactional Memory Extension at EL0.
      TME        : Boolean;      -- Enables the Transactional Memory Extension at EL1.
      EnASR      : Boolean;      -- When HCR_EL2.{E2H, TGE} != {1, 1}, traps execution of an ST64BV instruction at EL0 to EL1
      EnAS0      : Boolean;      -- When HCR_EL2.{E2H, TGE} != {1, 1}, traps execution of an ST64BV0 instruction at EL0 to EL1.
      EnALS      : Boolean;      -- When HCR_EL2.{E2H, TGE} != {1, 1}, traps execution of an LD64B or ST64B instruction at EL0 to EL1.
      EPAN       : Boolean;      -- Enhanced Privileged Access Never.
      Reserved3  : Bits_2  := 0;
      EnTP2      : Boolean;      -- Traps instructions executed at EL0 that access TPIDR2_EL0 to EL1, or to EL2 when EL2 is implemented and enabled for the current Security state and HCR_EL2.TGE is 1.
      NMI        : Boolean;      -- Non-maskable Interrupt enable.
      SPINTMASK  : Boolean;      -- SP Interrupt Mask enable.
      TIDCP      : Boolean;      -- Trap IMPLEMENTATION DEFINED functionality.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for SCTLR_EL1_Type use record
      M          at 0 range  0 ..  0;
      A          at 0 range  1 ..  1;
      C          at 0 range  2 ..  2;
      SA         at 0 range  3 ..  3;
      SA0        at 0 range  4 ..  4;
      CP15BEN    at 0 range  5 ..  5;
      nAA        at 0 range  6 ..  6;
      ITD        at 0 range  7 ..  7;
      SED        at 0 range  8 ..  8;
      UMA        at 0 range  9 ..  9;
      EnRCTX     at 0 range 10 .. 10;
      EOS        at 0 range 11 .. 11;
      I          at 0 range 12 .. 12;
      EnDB       at 0 range 13 .. 13;
      DZE        at 0 range 14 .. 14;
      UCT        at 0 range 15 .. 15;
      nTWI       at 0 range 16 .. 16;
      Reserved1  at 0 range 17 .. 17;
      nTWE       at 0 range 18 .. 18;
      WXN        at 0 range 19 .. 19;
      TSCXT      at 0 range 20 .. 20;
      IESB       at 0 range 21 .. 21;
      EIS        at 0 range 22 .. 22;
      SPAN       at 0 range 23 .. 23;
      E0E        at 0 range 24 .. 24;
      EE         at 0 range 25 .. 25;
      UCI        at 0 range 26 .. 26;
      EnDA       at 0 range 27 .. 27;
      nTLSMD     at 0 range 28 .. 28;
      LSMAOE     at 0 range 29 .. 29;
      EnIB       at 0 range 30 .. 30;
      EnIA       at 0 range 31 .. 31;
      CMOW       at 0 range 32 .. 32;
      MSCEn      at 0 range 33 .. 33;
      Reserved2  at 0 range 34 .. 34;
      BT0        at 0 range 35 .. 35;
      BT1        at 0 range 36 .. 36;
      ITFSB      at 0 range 37 .. 37;
      TCF0       at 0 range 38 .. 39;
      TCF        at 0 range 40 .. 41;
      ATA0       at 0 range 42 .. 42;
      ATA        at 0 range 43 .. 43;
      DSSBS      at 0 range 44 .. 44;
      TWEDEn     at 0 range 45 .. 45;
      TWEDEL     at 0 range 46 .. 49;
      TMT0       at 0 range 50 .. 50;
      TMT        at 0 range 51 .. 51;
      TME0       at 0 range 52 .. 52;
      TME        at 0 range 53 .. 53;
      EnASR      at 0 range 54 .. 54;
      EnAS0      at 0 range 55 .. 55;
      EnALS      at 0 range 56 .. 56;
      EPAN       at 0 range 57 .. 57;
      Reserved3  at 0 range 58 .. 59;
      EnTP2      at 0 range 60 .. 60;
      NMI        at 0 range 61 .. 61;
      SPINTMASK  at 0 range 62 .. 62;
      TIDCP      at 0 range 63 .. 63;
   end record;

   function SCTLR_EL1_Read
      return SCTLR_EL1_Type
      with Inline => True;
   procedure SCTLR_EL1_Write
      (Value : in SCTLR_EL1_Type)
      with Inline => True;

   -- D19.2.125 SCTLR_EL2, System Control Register (EL2)

   type SCTLR_EL2_Type is record
      M          : Boolean;      -- MMU enable for EL2 or EL2&0 stage 1 address translation.
      A          : Boolean;      -- Alignment check enable.
      C          : Boolean;      -- Data access Cacheability control, for accesses at EL2 and, when EL2 is enabled in the current Security state and HCR_EL2.{E2H, TGE} == {1, 1}, EL0
      SA         : Boolean;      -- SP Alignment check enable.
      SA0        : Boolean;      -- SP Alignment check enable for EL0.
      CP15BEN    : Boolean;      -- System instruction memory barrier enable.
      nAA        : Boolean;      -- Non-aligned access.
      ITD        : Boolean;      -- IT disable.
      SED        : Boolean;      -- SETEND instruction disable.
      Reserved1  : Bits_1  := 0;
      EnRCTX     : Boolean;      -- Enable EL0 access to the following System instructions:• CFPRCTX, DVPRCTX and CPPRCTX instructions.• CFP RCTX, DVP RCTX and CPP RCTX instructions.
      EOS        : Boolean;      -- Exception exit is a context synchronization event.
      I          : Boolean;      -- Instruction access Cacheability control, for accesses at EL2 and, when EL2 is enabled in the current Security state and HCR_EL2.{E2H,TGE} == {1,1}, EL0.
      EnDB       : Boolean;      -- Controls enabling of pointer authentication (using the APDBKey_EL1 key) of instruction addresses in the EL2 or EL2&0 translation regime.
      DZE        : Boolean;      -- Traps execution of DC ZVA instructions at EL0 to EL2, from AArch64 state only.
      UCT        : Boolean;      -- Traps EL0 accesses to the CTR_EL0 to EL2, from AArch64 state only.
      nTWI       : Boolean;      -- Traps execution of WFI instructions at EL0 to EL2, from both Execution states.
      Reserved2  : Bits_1  := 0;
      nTWE       : Boolean;      -- Traps execution of WFE instructions at EL0 to EL2, from both Execution states.
      WXN        : Boolean;      -- Write permission implies XN (Execute-never).
      TSCXT      : Boolean;      -- Trap EL0 Access to the SCXTNUM_EL0 register, when EL0 is using AArch64.
      IESB       : Boolean;      -- Implicit Error Synchronization event enable.
      EIS        : Boolean;      -- Exception entry is a context synchronization event.
      SPAN       : Boolean;      -- Set Privileged Access Never, on taking an exception to EL2.
      E0E        : Bits_1;       -- Endianness of data accesses at EL0.
      EE         : Bits_1;       -- Endianness of data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&0 translation regime, and stage 2 translation table walks in the EL1&0 translation regime.
      UCI        : Boolean;      -- Traps execution of cache maintenance instructions at EL0 to EL2, from AArch64 state only. This applies to DC CVAU, DC CIVAC, DC CVAC, DC CVAP, and IC IVAU.
      EnDA       : Boolean;      -- Controls enabling of pointer authentication (using the APDAKey_EL1 key) of instruction addressesin the EL2 or EL2&0 translation regime.
      nTLSMD     : Boolean;      -- No Trap Load Multiple and Store Multiple to Device-nGRE/Device-nGnRE/Device-nGnRnE memory.
      LSMAOE     : Boolean;      -- Load Multiple and Store Multiple Atomicity and Ordering Enable.
      EnIB       : Boolean;      -- Controls enabling of pointer authentication (using the APIBKey_EL1 key) of instruction addresses in the EL2 or EL2&0 translation regime.
      EnIA       : Boolean;      -- Controls enabling of pointer authentication (using the APIAKey_EL1 key) of instruction addresses in the EL2 or EL2&0 translation regime.
      CMOW       : Boolean;      -- Controls cache maintenance instruction permission for the following instructions executed at EL0.• IC IVAU, DC CIVAC, DC CIGDVAC and DC CIGVAC.
      MSCEn      : Boolean;      -- Memory Copy and Memory Set instructions Enable. Enables execution of the Memory Copy and Memory Set instructions at EL0.
      Reserved3  : Bits_1  := 0;
      BT0        : Boolean;      -- PAC Branch Type compatibility at EL0.
      BT         : Boolean;      -- PAC Branch Type compatibility at EL2.
      ITFSB      : Boolean;      -- When synchronous exceptions are not being generated by Tag Check Faults, this field controls whether on exception entry into EL2, all Tag Check Faults due to instructions executed before exception entry, that are reported asynchronously, are synchronized into TFSRE0_EL1, TFSR_EL1 and TFSR_EL2 registers.
      TCF0       : Bits_2;       -- Tag Check Fault in EL0. Controls the effect of Tag Check Faults due to Loads and Stores in EL0.
      TCF        : Bits_2;       -- Tag Check Fault in EL2. Controls the effect of Tag Check Faults due to Loads and Stores in EL2.
      ATA0       : Boolean;      -- Allocation Tag Access in EL0.
      ATA        : Boolean;      -- Allocation Tag Access in EL2.
      DSSBS      : Bits_1;       -- Default PSTATE.SSBS value on Exception Entry.
      TWEDEn     : Boolean;      -- TWE Delay Enable.
      TWEDEL     : Bits_4;       -- TWE Delay.
      TMT0       : Boolean;      -- Forces a trivial implementation of the Transactional Memory Extension at EL0.
      TMT        : Boolean;      -- Forces a trivial implementation of the Transactional Memory Extension at EL2.
      TME0       : Boolean;      -- Enables the Transactional Memory Extension at EL0.
      TME        : Boolean;      -- Enables the Transactional Memory Extension at EL2.
      EnASR      : Boolean;      -- Traps execution of an ST64BV instruction at EL0 to EL2.
      EnAS0      : Boolean;      -- Traps execution of an ST64BV0 instruction at EL0 to EL2.
      EnALS      : Boolean;      -- Traps execution of an LD64B or ST64B instruction at EL0 to EL2.
      EPAN       : Boolean;      -- Enhanced Privileged Access Never.
      Reserved4  : Bits_2  := 0;
      EnTP2      : Boolean;      -- Traps instructions executed at EL0 that access TPIDR2_EL0 to EL2 when EL2 is implemented and enabled for the current Security state.
      NMI        : Boolean;      -- Non-maskable Interrupt enable.
      SPINTMASK  : Boolean;      -- SP Interrupt Mask enable.
      TIDCP      : Boolean;      -- Trap IMPLEMENTATION DEFINED functionality.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for SCTLR_EL2_Type use record
      M          at 0 range  0 ..  0;
      A          at 0 range  1 ..  1;
      C          at 0 range  2 ..  2;
      SA         at 0 range  3 ..  3;
      SA0        at 0 range  4 ..  4;
      CP15BEN    at 0 range  5 ..  5;
      nAA        at 0 range  6 ..  6;
      ITD        at 0 range  7 ..  7;
      SED        at 0 range  8 ..  8;
      Reserved1  at 0 range  9 ..  9;
      EnRCTX     at 0 range 10 .. 10;
      EOS        at 0 range 11 .. 11;
      I          at 0 range 12 .. 12;
      EnDB       at 0 range 13 .. 13;
      DZE        at 0 range 14 .. 14;
      UCT        at 0 range 15 .. 15;
      nTWI       at 0 range 16 .. 16;
      Reserved2  at 0 range 17 .. 17;
      nTWE       at 0 range 18 .. 18;
      WXN        at 0 range 19 .. 19;
      TSCXT      at 0 range 20 .. 20;
      IESB       at 0 range 21 .. 21;
      EIS        at 0 range 22 .. 22;
      SPAN       at 0 range 23 .. 23;
      E0E        at 0 range 24 .. 24;
      EE         at 0 range 25 .. 25;
      UCI        at 0 range 26 .. 26;
      EnDA       at 0 range 27 .. 27;
      nTLSMD     at 0 range 28 .. 28;
      LSMAOE     at 0 range 29 .. 29;
      EnIB       at 0 range 30 .. 30;
      EnIA       at 0 range 31 .. 31;
      CMOW       at 0 range 32 .. 32;
      MSCEn      at 0 range 33 .. 33;
      Reserved3  at 0 range 34 .. 34;
      BT0        at 0 range 35 .. 35;
      BT         at 0 range 36 .. 36;
      ITFSB      at 0 range 37 .. 37;
      TCF0       at 0 range 38 .. 39;
      TCF        at 0 range 40 .. 41;
      ATA0       at 0 range 42 .. 42;
      ATA        at 0 range 43 .. 43;
      DSSBS      at 0 range 44 .. 44;
      TWEDEn     at 0 range 45 .. 45;
      TWEDEL     at 0 range 46 .. 49;
      TMT0       at 0 range 50 .. 50;
      TMT        at 0 range 51 .. 51;
      TME0       at 0 range 52 .. 52;
      TME        at 0 range 53 .. 53;
      EnASR      at 0 range 54 .. 54;
      EnAS0      at 0 range 55 .. 55;
      EnALS      at 0 range 56 .. 56;
      EPAN       at 0 range 57 .. 57;
      Reserved4  at 0 range 58 .. 59;
      EnTP2      at 0 range 60 .. 60;
      NMI        at 0 range 61 .. 61;
      SPINTMASK  at 0 range 62 .. 62;
      TIDCP      at 0 range 63 .. 63;
   end record;

   function SCTLR_EL2_Read
      return SCTLR_EL2_Type
      with Inline => True;
   procedure SCTLR_EL2_Write
      (Value : in SCTLR_EL2_Type)
      with Inline => True;

   -- D19.2.126 SCTLR_EL3, System Control Register (EL3)

   type SCTLR_EL3_Type is record
      M          : Boolean;      -- MMU enable for EL3 stage 1 address translation.
      A          : Boolean;      -- Alignment check enable.
      C          : Boolean;      -- Cacheability control, for data accesses.
      SA         : Boolean;      -- SP Alignment check enable.
      Reserved1  : Bits_2  := 0;
      nAA        : Boolean;      -- Non-aligned access.
      Reserved2  : Bits_4  := 0;
      EOS        : Boolean;      -- Exception Exit is Context Synchronizing.
      I          : Boolean;      -- Instruction access Cacheability control, for accesses at EL3:
      EnDB       : Boolean;      -- Controls enabling of pointer authentication (using the APDBKey_EL1 key) of instruction addresses in the EL3 translation regime.
      Reserved3  : Bits_2  := 0;
      Reserved4  : Bits_1  := 0;
      Reserved5  : Bits_1  := 0;
      Reserved6  : Bits_1  := 0;
      WXN        : Boolean;      -- Write permission implies XN (Execute-never).
      Reserved7  : Bits_1  := 0;
      IESB       : Boolean;      -- Implicit Error Synchronization event enable.
      EIS        : Boolean;      -- Exception Entry is Context Synchronizing.
      Reserved8  : Bits_1  := 0;
      Reserved9  : Bits_1  := 0;
      EE         : Bits_1;       -- Endianness of data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime.
      Reserved10 : Bits_1  := 0;
      EnDA       : Boolean;      -- Controls enabling of pointer authentication (using the APDAKey_EL1 key) of instruction addresses in the EL3 translation regime.
      Reserved11 : Bits_2  := 0;
      EnIB       : Boolean;      -- Controls enabling of pointer authentication (using the APIBKey_EL1 key) of instruction addresses in the EL3 translation regime.
      EnIA       : Boolean;      -- Controls enabling of pointer authentication (using the APIAKey_EL1 key) of instruction addresses in the EL3 translation regime.
      Reserved12 : Bits_4  := 0;
      BT         : Boolean;      -- PAC Branch Type compatibility at EL3.
      ITFSB      : Boolean;      -- When synchronous exceptions are not being generated by Tag Check Faults, this field controls whether on exception entry into EL3, all Tag Check Faults due to instructions executed before exception entry, that are reported asynchronously, are synchronized into TFSRE0_EL1 and TFSR_ELx registers.      TCF0       : Bits_2;       --
      Reserved13 : Bits_2  := 0;
      TCF        : Bits_2;       -- Tag Check Fault in EL3. Controls the effect of Tag Check Faults due to Loads and Stores in EL3.
      Reserved14 : Bits_1  := 0;
      ATA        : Boolean;      -- Allocation Tag Access in EL3.
      DSSBS      : Bits_1;       -- Default PSTATE.SSBS value on Exception Entry.
      Reserved15 : Bits_6  := 0;
      TMT        : Boolean;      -- Forces a trivial implementation of the Transactional Memory Extension at EL3.
      Reserved16 : Bits_1  := 0;
      TME        : Boolean;      -- Enables the Transactional Memory Extension at EL3.
      Reserved17 : Bits_7  := 0;
      NMI        : Boolean;      -- Non-maskable Interrupt enable.
      SPINTMASK  : Boolean;      -- SP Interrupt Mask enable.
      Reserved18 : Bits_1  := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for SCTLR_EL3_Type use record
      M          at 0 range  0 ..  0;
      A          at 0 range  1 ..  1;
      C          at 0 range  2 ..  2;
      SA         at 0 range  3 ..  3;
      Reserved1  at 0 range  4 ..  5;
      nAA        at 0 range  6 ..  6;
      Reserved2  at 0 range  7 .. 10;
      EOS        at 0 range 11 .. 11;
      I          at 0 range 12 .. 12;
      EnDB       at 0 range 13 .. 13;
      Reserved3  at 0 range 14 .. 15;
      Reserved4  at 0 range 16 .. 16;
      Reserved5  at 0 range 17 .. 17;
      Reserved6  at 0 range 18 .. 18;
      WXN        at 0 range 19 .. 19;
      Reserved7  at 0 range 20 .. 20;
      IESB       at 0 range 21 .. 21;
      EIS        at 0 range 22 .. 22;
      Reserved8  at 0 range 23 .. 23;
      Reserved9  at 0 range 24 .. 24;
      EE         at 0 range 25 .. 25;
      Reserved10 at 0 range 26 .. 26;
      EnDA       at 0 range 27 .. 27;
      Reserved11 at 0 range 28 .. 29;
      EnIB       at 0 range 30 .. 30;
      EnIA       at 0 range 31 .. 31;
      Reserved12 at 0 range 32 .. 35;
      BT         at 0 range 36 .. 36;
      ITFSB      at 0 range 37 .. 37;
      Reserved13 at 0 range 38 .. 39;
      TCF        at 0 range 40 .. 41;
      Reserved14 at 0 range 42 .. 42;
      ATA        at 0 range 43 .. 43;
      DSSBS      at 0 range 44 .. 44;
      Reserved15 at 0 range 45 .. 50;
      TMT        at 0 range 51 .. 51;
      Reserved16 at 0 range 52 .. 52;
      TME        at 0 range 53 .. 53;
      Reserved17 at 0 range 54 .. 60;
      NMI        at 0 range 61 .. 61;
      SPINTMASK  at 0 range 62 .. 62;
      Reserved18 at 0 range 63 .. 63;
   end record;

   function SCTLR_EL3_Read
      return SCTLR_EL3_Type
      with Inline => True;
   procedure SCTLR_EL3_Write
      (Value : in SCTLR_EL3_Type)
      with Inline => True;

   -- D19.2.127 SCXTNUM_EL0, EL0 Read/Write Software Context Number
   -- D19.2.128 SCXTNUM_EL1, EL1 Read/Write Software Context Number
   -- D19.2.129 SCXTNUM_EL2, EL2 Read/Write Software Context Number
   -- D19.2.130 SCXTNUM_EL3, EL3 Read/Write Software Context Number
   -- D19.2.131 SMCR_EL1, SME Control Register (EL1)
   -- D19.2.132 SMCR_EL2, SME Control Register (EL2)
   -- D19.2.133 SMCR_EL3, SME Control Register (EL3)
   -- D19.2.134 SMIDR_EL1, Streaming Mode Identification Register
   -- D19.2.135 SMPRIMAP_EL2, Streaming Mode Priority Mapping Register
   -- D19.2.136 SMPRI_EL1, Streaming Mode Priority Register

#if TCR2_EL1
   -- D19.2.137 TCR2_EL1, Extended Translation Control Register (EL1)

   type TCR2_EL1_Type is new Bits.Bitmap_64;

   function TCR2_EL1_Read
      return TCR2_EL1_Type
      with Inline => True;
   procedure TCR2_EL1_Write
      (Value : in TCR2_EL1_Type)
      with Inline => True;
#end if;

#if TCR2_EL2
   -- D19.2.138 TCR2_EL2, Extended Translation Control Register (EL2)

   type TCR2_EL2_Type is new Bits.Bitmap_64;

   function TCR2_EL2_Read
      return TCR2_EL2_Type
      with Inline => True;
   procedure TCR2_EL2_Write
      (Value : in TCR2_EL2_Type)
      with Inline => True;
#end if;

   -- D19.2.139 TCR_EL1, Translation Control Register (EL1)
   -- D19.2.140 TCR_EL2, Translation Control Register (EL2)
   -- D19.2.141 TCR_EL3, Translation Control Register (EL3)

   IRGN_NM          : constant := 2#00#; -- Normal memory, Inner Non-cacheable.
   IRGN_NM_IWBRAWAC : constant := 2#01#; -- Normal memory, Inner Write-Back Read-Allocate Write-Allocate Cacheable.
   IRGN_NM_IWTRA    : constant := 2#10#; -- Normal memory, Inner Write-Through Read-Allocate No Write-Allocate Cacheable.
   IRGN_NM_IWBRA    : constant := 2#11#; -- Normal memory, Inner Write-Back Read-Allocate No Write-Allocate Cacheable.

   ORGN_NM          : constant := 2#00#; -- Normal memory, Outer Non-cacheable.
   ORGN_NM_IWBRAWAC : constant := 2#01#; -- Normal memory, Outer Write-Back Read-Allocate Write-Allocate Cacheable.
   ORGN_NM_IWTRA    : constant := 2#10#; -- Normal memory, Outer Write-Through Read-Allocate No Write-Allocate Cacheable.
   ORGN_NM_IWBRA    : constant := 2#11#; -- Normal memory, Outer Write-Back Read-Allocate No Write-Allocate Cacheable.

   SH_NOSHARE : constant := 2#00#; -- Non-shareable
   SH_OUTER   : constant := 2#10#; -- Outer Shareable
   SH_INNER   : constant := 2#11#; -- Inner Shareable

   TG_4  : constant := 2#00#; -- 4KB
   TG_64 : constant := 2#01#; -- 64KB
   TG_16 : constant := 2#10#; -- 16KB

   PS_GB4   : constant := 2#000#; -- 32 bits, 4GB.
   PS_GB64  : constant := 2#001#; -- 36 bits, 64GB.
   PS_TB1   : constant := 2#010#; -- 40 bits, 1TB.
   PS_TB4   : constant := 2#011#; -- 42 bits, 4TB.
   PS_TB16  : constant := 2#100#; -- 44 bits, 16TB.
   PS_TB256 : constant := 2#101#; -- 48 bits, 256TB.
   PS_PB4   : constant := 2#110#; -- 52 bits, 4PB.

   A1_TTBR0 : constant := 0; -- TTBR0_EL1.ASID defines the ASID.
   A1_TTBR1 : constant := 1; -- TTBR1_EL1.ASID defines the ASID.

   IPS_4G    : constant := 2#000#; -- 32 bits, 4GB.
   IPS_64G   : constant := 2#001#; -- 36 bits, 64GB.
   IPS_1TB   : constant := 2#010#; -- 40 bits, 1TB.
   IPS_4TB   : constant := 2#011#; -- 42 bits, 4TB.
   IPS_16TB  : constant := 2#100#; -- 44 bits, 16TB.
   IPS_256TB : constant := 2#101#; -- 48 bits, 256TB.
   IPS_4PB   : constant := 2#110#; -- 52 bits, 4PB.

   AS_8  : constant := 0; -- 8 bit - the upper 8 bits of TTBR0_EL1 and TTBR1_EL1 are ignored by hardware for every purpose except reading back the register, and are treated as if they are all zeros for when used for allocation and matching entries in the TLB.
   AS_16 : constant := 1; -- 16 bit - the upper 16 bits of TTBR0_EL1 and TTBR1_EL1 are used for allocation and matching in the TLB.

   type TCR_EL1_Type is record
      T0SZ      : Bits_6  := 0;          -- The size offset of the memory region addressed by TTBR0_EL1.
      Reserved1 : Bits_1  := 0;
      EPD0      : Boolean := False;      -- Translation table walk disable for translations using TTBR0_EL1.
      IRGN0     : Bits_2  := IRGN_NM;    -- Inner cacheability attribute for memory associated with translation table walks using TTBR0_EL1.
      ORGN0     : Bits_2  := ORGN_NM;    -- Outer cacheability attribute for memory associated with translation table walks using TTBR0_EL1.
      SH0       : Bits_2  := SH_NOSHARE; -- Shareability attribute for memory associated with translation table walks using TTBR0_EL1.
      TG0       : Bits_2  := TG_4;       -- Granule size for the TTBR0_EL1.
      T1SZ      : Bits_6  := 0;          -- The size offset of the memory region addressed by TTBR1_EL1.
      A1        : Bits_1  := A1_TTBR0;   -- Selects whether TTBR0_EL1 or TTBR1_EL1 defines the ASID.
      EPD1      : Boolean := False;      -- Translation table walk disable for translations using TTBR1_EL1.
      IRGN1     : Bits_2  := IRGN_NM;    -- Inner cacheability attribute for memory associated with translation table walks using TTBR1_EL1.
      ORGN1     : Bits_2  := ORGN_NM;    -- Outer cacheability attribute for memory associated with translation table walks using TTBR1_EL1.
      SH1       : Bits_2  := SH_NOSHARE; -- Shareability attribute for memory associated with translation table walks using TTBR1_EL1.
      TG1       : Bits_2  := TG_4;       -- Granule size for the TTBR1_EL1.
      IPS       : Bits_3  := 0;          -- Intermediate Physical Address Size.
      Reserved2 : Bits_1  := 0;
      AS        : Boolean := False;      -- ASID Size.
      TBI0      : Boolean := False;      -- Top Byte ignored. Indicates whether the top byte of an address is used for address match for the TTBR0_EL1 region, or ignored and used for tagged addresses.
      TBI1      : Boolean := False;      -- Top Byte ignored. Indicates whether the top byte of an address is used for address match for the TTBR1_EL1 region, or ignored and used for tagged addresses.
      HA        : Boolean := False;      -- Hardware Access flag update in stage 1 translations from EL0 and EL1.
      HD        : Boolean := False;      -- Hardware management of dirty state in stage 1 translations from EL0 and EL1.
      HPD0      : Boolean := False;      -- Hierarchical Permission Disables. This affects the hierarchical control bits, APTable, PXNTable, and UXNTable, except NSTable, in the translation tables pointed to by TTBR0_EL1.
      HPD1      : Boolean := False;      -- Hierarchical Permission Disables. This affects the hierarchical control bits, APTable, PXNTable, and UXNTable, except NSTable, in the translation tables pointed to by TTBR1_EL1.
      HWU059    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[59] of the stage 1 translation table Block or Page entry for translations using TTBR0_EL1.
      HWU060    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[60] of the stage 1 translation table Block or Page entry for translations using TTBR0_EL1.
      HWU061    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[61] of the stage 1 translation table Block or Page entry for translations using TTBR0_EL1.
      HWU062    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[62] of the stage 1 translation table Block or Page entry for translations using TTBR0_EL1.
      HWU159    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[59] of the stage 1 translation table Block or Page entry for translations using TTBR1_EL1.
      HWU160    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[60] of the stage 1 translation table Block or Page entry for translations using TTBR1_EL1.
      HWU161    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[61] of the stage 1 translation table Block or Page entry for translations using TTBR1_EL1.
      HWU162    : Boolean := False;      -- Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[62] of the stage 1 translation table Block or Page entry for translations using TTBR1_EL1.
      TBID0     : Boolean := False;      -- Controls the use of the top byte of instruction addresses for address matching.
      TBID1     : Boolean := False;      -- Controls the use of the top byte of instruction addresses for address matching.
      NFD0      : Boolean := False;      -- Non-fault translation timing disable for stage 1 translations using TTBR0_EL1.
      NFD1      : Boolean := False;      -- Non-fault translation timing disable for stage 1 translations using TTBR1_EL1.
      E0PD0     : Boolean := False;      -- Faulting control for Unprivileged access to any address translated by TTBR0_EL1.
      E0PD1     : Boolean := False;      -- Faulting control for Unprivileged access to any address translated by TTBR1_EL1.
      TCMA0     : Boolean := False;      -- Controls the generation of Unchecked accesses at EL1, and at EL0 if HCR_EL2.{E2H,TGE}!={1,1}, when address[59:55] = 0b00000.
      TCMA1     : Boolean := False;      -- Controls the generation of Unchecked accesses at EL1, and at EL0 if HCR_EL2.{E2H,TGE}!={1,1}, when address[59:55] = 0b11111.
      DS        : Boolean := False;      -- This field affects whether a 52-bit output address can be described by the translation tables of the 4KB or 16KB translation granules.
      Reserved3 : Bits_4  := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for TCR_EL1_Type use record
      T0SZ      at 0 range  0 ..  5;
      Reserved1 at 0 range  6 ..  6;
      EPD0      at 0 range  7 ..  7;
      IRGN0     at 0 range  8 ..  9;
      ORGN0     at 0 range 10 .. 11;
      SH0       at 0 range 12 .. 13;
      TG0       at 0 range 14 .. 15;
      T1SZ      at 0 range 16 .. 21;
      A1        at 0 range 22 .. 22;
      EPD1      at 0 range 23 .. 23;
      IRGN1     at 0 range 24 .. 25;
      ORGN1     at 0 range 26 .. 27;
      SH1       at 0 range 28 .. 29;
      TG1       at 0 range 30 .. 31;
      IPS       at 0 range 32 .. 34;
      Reserved2 at 0 range 35 .. 35;
      AS        at 0 range 36 .. 36;
      TBI0      at 0 range 37 .. 37;
      TBI1      at 0 range 38 .. 38;
      HA        at 0 range 39 .. 39;
      HD        at 0 range 40 .. 40;
      HPD0      at 0 range 41 .. 41;
      HPD1      at 0 range 42 .. 42;
      HWU059    at 0 range 43 .. 43;
      HWU060    at 0 range 44 .. 44;
      HWU061    at 0 range 45 .. 45;
      HWU062    at 0 range 46 .. 46;
      HWU159    at 0 range 47 .. 47;
      HWU160    at 0 range 48 .. 48;
      HWU161    at 0 range 49 .. 49;
      HWU162    at 0 range 50 .. 50;
      TBID0     at 0 range 51 .. 51;
      TBID1     at 0 range 52 .. 52;
      NFD0      at 0 range 53 .. 53;
      NFD1      at 0 range 54 .. 54;
      E0PD0     at 0 range 55 .. 55;
      E0PD1     at 0 range 56 .. 56;
      TCMA0     at 0 range 57 .. 57;
      TCMA1     at 0 range 58 .. 58;
      DS        at 0 range 59 .. 59;
      Reserved3 at 0 range 60 .. 63;
   end record;

   function TCR_EL1_Read
      return TCR_EL1_Type
      with Inline => True;
   procedure TCR_EL1_Write
      (Value : in TCR_EL1_Type)
      with Inline => True;

   type TCR_EL2_Type is record
      T0SZ      : Bits_6  := 0;          -- The size offset of the memory region addressed by TTBR0_EL2.
      Reserved1 : Bits_2  := 0;
      IRGN0     : Bits_2  := IRGN_NM;    -- Inner cacheability attribute for memory associated with translation table walks using TTBR0_EL2.
      ORGN0     : Bits_2  := ORGN_NM;    -- Outer cacheability attribute for memory associated with translation table walks using TTBR0_EL2.
      SH0       : Bits_2  := SH_NOSHARE; -- Shareability attribute for memory associated with translation table walks using TTBR0_EL2.
      TG0       : Bits_2  := TG_4;       -- Granule size for the TTBR0_EL2.
      PS        : Bits_3  := PS_GB4;     -- Physical Address Size.
      Reserved2 : Bits_1  := 0;
      TBI       : Boolean := False;      -- Top Byte Ignored.
      HA        : Boolean := False;      -- Hardware Access flag update in stage 1 translations from EL2.
      HD        : Boolean := False;      -- Hardware management of dirty state in stage 1 translations from EL2.
      Reserved3 : Bits_1  := 0;
      HPD       : Boolean := False;      -- Hierarchical Permission Disables.
      HWU59     : Boolean := False;      -- Hardware Use.
      HWU60     : Boolean := False;      -- Hardware Use.
      HWU61     : Boolean := False;      -- Hardware Use.
      HWU62     : Boolean := False;      -- Hardware Use.
      TBID      : Boolean := False;      -- Controls the use of the top byte of instruction addresses for address matching.
      TCMA      : Boolean := False;      -- Controls the generation of Unchecked accesses at EL2 when address [59:56] = 0b0000.
      Reserved4 : Bits_1  := 0;
      DS        : Boolean := False;      -- This field affects whether a 52-bit output address can be described by the translation tables of the 4KB or 16KB translation granules.
      Reserved5 : Bits_31 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for TCR_EL2_Type use record
      T0SZ      at 0 range  0 ..  5;
      Reserved1 at 0 range  6 ..  7;
      IRGN0     at 0 range  8 ..  9;
      ORGN0     at 0 range 10 .. 11;
      SH0       at 0 range 12 .. 13;
      TG0       at 0 range 14 .. 15;
      PS        at 0 range 16 .. 18;
      Reserved2 at 0 range 19 .. 19;
      TBI       at 0 range 20 .. 20;
      HA        at 0 range 21 .. 21;
      HD        at 0 range 22 .. 22;
      Reserved3 at 0 range 23 .. 23;
      HPD       at 0 range 24 .. 24;
      HWU59     at 0 range 25 .. 25;
      HWU60     at 0 range 26 .. 26;
      HWU61     at 0 range 27 .. 27;
      HWU62     at 0 range 28 .. 28;
      TBID      at 0 range 29 .. 29;
      TCMA      at 0 range 30 .. 30;
      Reserved4 at 0 range 31 .. 31;
      DS        at 0 range 32 .. 32;
      Reserved5 at 0 range 33 .. 63;
   end record;

   function TCR_EL2_Read
      return TCR_EL2_Type
      with Inline => True;
   procedure TCR_EL2_Write
      (Value : in TCR_EL2_Type)
      with Inline => True;

   type TCR_EL3_Type is record
      T0SZ      : Bits_6  := 0;          -- The size offset of the memory region addressed by TTBR0_EL3.
      Reserved1 : Bits_2  := 0;
      IRGN0     : Bits_2  := IRGN_NM;    -- Inner cacheability attribute for memory associated with translation table walks using TTBR0_EL3.
      ORGN0     : Bits_2  := ORGN_NM;    -- Outer cacheability attribute for memory associated with translation table walks using TTBR0_EL3.
      SH0       : Bits_2  := SH_NOSHARE; -- Shareability attribute for memory associated with translation table walks using TTBR0_EL3.
      TG0       : Bits_2  := TG_4;       -- Granule size for the TTBR0_EL3.
      PS        : Bits_3  := PS_GB4;     -- Physical Address Size.
      Reserved2 : Bits_1  := 0;
      TBI       : Boolean := False;      -- Top Byte Ignored.
      HA        : Boolean := False;      -- Hardware Access flag update in stage 1 translations from EL3.
      HD        : Boolean := False;      -- Hardware management of dirty state in stage 1 translations from EL3.
      Reserved3 : Bits_1  := 0;
      HPD       : Boolean := False;      -- Hierarchical Permission Disables.
      HWU59     : Boolean := False;      -- Hardware Use.
      HWU60     : Boolean := False;      -- Hardware Use.
      HWU61     : Boolean := False;      -- Hardware Use.
      HWU62     : Boolean := False;      -- Hardware Use.
      TBID      : Boolean := False;      -- Controls the use of the top byte of instruction addresses for address matching.
      TCMA      : Boolean := False;      -- Controls the generation of Unchecked accesses at EL3 when address [59:56] = 0b0000.
      Reserved4 : Bits_1  := 0;
      DS        : Boolean := False;      -- This field affects whether a 52-bit output address can be described by the translation tables of the 4KB or 16KB translation granules.
      Reserved5 : Bits_31 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for TCR_EL3_Type use record
      T0SZ      at 0 range  0 ..  5;
      Reserved1 at 0 range  6 ..  7;
      IRGN0     at 0 range  8 ..  9;
      ORGN0     at 0 range 10 .. 11;
      SH0       at 0 range 12 .. 13;
      TG0       at 0 range 14 .. 15;
      PS        at 0 range 16 .. 18;
      Reserved2 at 0 range 19 .. 19;
      TBI       at 0 range 20 .. 20;
      HA        at 0 range 21 .. 21;
      HD        at 0 range 22 .. 22;
      Reserved3 at 0 range 23 .. 23;
      HPD       at 0 range 24 .. 24;
      HWU59     at 0 range 25 .. 25;
      HWU60     at 0 range 26 .. 26;
      HWU61     at 0 range 27 .. 27;
      HWU62     at 0 range 28 .. 28;
      TBID      at 0 range 29 .. 29;
      TCMA      at 0 range 30 .. 30;
      Reserved4 at 0 range 31 .. 31;
      DS        at 0 range 32 .. 32;
      Reserved5 at 0 range 33 .. 63;
   end record;

   function TCR_EL3_Read
      return TCR_EL3_Type
      with Inline => True;
   procedure TCR_EL3_Write
      (Value : in TCR_EL3_Type)
      with Inline => True;

   -- D19.2.142 TFSRE0_EL1, Tag Fault Status Register (EL0).
   -- D19.2.143 TFSR_EL1, Tag Fault Status Register (EL1)
   -- D19.2.144 TFSR_EL2, Tag Fault Status Register (EL2)
   -- D19.2.145 TFSR_EL3, Tag Fault Status Register (EL3)
   -- D19.2.146 TPIDR2_EL0, EL0 Read/Write Software Thread ID Register 2
   -- D19.2.147 TPIDR_EL0, EL0 Read/Write Software Thread ID Register
   -- D19.2.148 TPIDR_EL1, EL1 Software Thread ID Register
   -- D19.2.149 TPIDR_EL2, EL2 Software Thread ID Register
   -- D19.2.150 TPIDR_EL3, EL3 Software Thread ID Register
   -- D19.2.151 TPIDRRO_EL0, EL0 Read-Only Software Thread ID Register

   -- D19.2.152 TTBR0_EL1, Translation Table Base Register 0 (EL1)
   -- D19.2.153 TTBR0_EL2, Translation Table Base Register 0 (EL2)
   -- D19.2.154 TTBR0_EL3, Translation Table Base Register 0 (EL3)
   -- D19.2.155 TTBR1_EL1, Translation Table Base Register 1 (EL1)
   -- D19.2.156 TTBR1_EL2, Translation Table Base Register 1 (EL2)

   CnP_DIFFER : constant := 0; -- The translation table entries pointed to by TTBR1_EL2 for the current ASID are permitted to differ from corresponding entries for TTBR1_EL2 for other PEs in the Inner Shareable domain.
   CnP_SAME   : constant := 1; -- The translation table entries pointed to by TTBR1_EL2 are the same as the translation table entries for every other PE in the Inner Shareable domain for which the value of TTBR1_EL2.CnP is 1 and all of the following apply: ...

   type TTBR0_EL1_Type is record
      CnP   : Bits_1;  -- Common not Private.
      BADDR : Bits_47; -- Translation table base address
      ASID  : Bits_16; -- An ASID for the translation table base address.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for TTBR0_EL1_Type use record
      CnP   at 0 range  0 ..  0;
      BADDR at 0 range  1 .. 47;
      ASID  at 0 range 48 .. 63;
   end record;

   function TTBR0_EL1_Read
      return TTBR0_EL1_Type
      with Inline => True;
   procedure TTBR0_EL1_Write
      (Value : in TTBR0_EL1_Type)
      with Inline => True;

   type TTBR0_EL2_Type is new TTBR0_EL1_Type;

   function TTBR0_EL2_Read
      return TTBR0_EL2_Type
      with Inline => True;
   procedure TTBR0_EL2_Write
      (Value : in TTBR0_EL2_Type)
      with Inline => True;

   type TTBR0_EL3_Type is record
      CnP      : Bits_1;       -- Common not Private.
      BADDR    : Bits_47;      -- Translation table base address
      Reserved : Bits_16 := 0; -- An ASID for the translation table base address.
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for TTBR0_EL3_Type use record
      CnP      at 0 range  0 ..  0;
      BADDR    at 0 range  1 .. 47;
      Reserved at 0 range 48 .. 63;
   end record;

   function TTBR0_EL3_Read
      return TTBR0_EL3_Type
      with Inline => True;
   procedure TTBR0_EL3_Write
      (Value : in TTBR0_EL3_Type)
      with Inline => True;

   type TTBR1_EL1_Type is new TTBR0_EL1_Type;

   function TTBR1_EL1_Read
      return TTBR1_EL1_Type
      with Inline => True;
   procedure TTBR1_EL1_Write
      (Value : in TTBR1_EL1_Type)
      with Inline => True;

#if TTBR1_EL2
   type TTBR1_EL2_Type is new TTBR0_EL1_Type;

   function TTBR1_EL2_Read
      return TTBR1_EL2_Type
      with Inline => True;
   procedure TTBR1_EL2_Write
      (Value : in TTBR1_EL2_Type)
      with Inline => True;
#end if;

   -- D19.2.157 VBAR_EL1, Vector Base Address Register (EL1)
   -- D19.2.158 VBAR_EL2, Vector Base Address Register (EL2)
   -- D19.2.159 VBAR_EL3, Vector Base Address Register (EL3)

   function VBAR_EL1_Read
      return Unsigned_64
      with Inline => True;
   procedure VBAR_EL1_Write
      (Value : in Unsigned_64)
      with Inline => True;
   function VBAR_EL2_Read
      return Unsigned_64
      with Inline => True;
   procedure VBAR_EL2_Write
      (Value : in Unsigned_64)
      with Inline => True;
   function VBAR_EL3_Read
      return Unsigned_64
      with Inline => True;
   procedure VBAR_EL3_Write
      (Value : in Unsigned_64)
      with Inline => True;

   -- D19.2.160 VMPIDR_EL2, Virtualization Multiprocessor ID Register
   -- D19.2.161 VNCR_EL2, Virtual Nested Control Register
   -- D19.2.162 VPIDR_EL2, Virtualization Processor ID Register
   -- D19.2.163 VSTCR_EL2, Virtualization Secure Translation Control Register
   -- D19.2.164 VSTTBR_EL2, Virtualization Secure Translation Table Base Register
   -- D19.2.165 VTCR_EL2, Virtualization Translation Control Register
   -- D19.2.166 VTTBR_EL2, Virtualization Translation Table Base Register
   -- D19.2.167 ZCR_EL1, SVE Control Register (EL1)
   -- D19.2.168 ZCR_EL2, SVE Control Register (EL2)
   -- D19.2.169 ZCR_EL3, SVE Control Register (EL3)

   ----------------------------------------------------------------------------
   -- D19.12 Generic Timer registers
   ----------------------------------------------------------------------------

   -- D19.12.1 CNTFRQ_EL0, Counter-timer Frequency register

   type CNTFRQ_EL0_Type is record
      Clock_frequency : Unsigned_32;      -- Clock_Frequency.
      Reserved        : Bits_32     := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CNTFRQ_EL0_Type use record
      Clock_frequency at 0 range  0 .. 31;
      Reserved        at 0 range 32 .. 63;
   end record;

   function CNTFRQ_EL0_Read
      return CNTFRQ_EL0_Type
      with Inline => True;

   -- D19.12.2 CNTHCTL_EL2, Counter-timer Hypervisor Control register
   -- D19.12.3 CNTHP_CTL_EL2, Counter-timer Hypervisor Physical Timer Control register
   -- D19.12.4 CNTHP_CVAL_EL2, Counter-timer Physical Timer CompareValue register (EL2)
   -- D19.12.5 CNTHP_TVAL_EL2, Counter-timer Physical Timer TimerValue register (EL2)
   -- D19.12.6 CNTHPS_CTL_EL2, Counter-timer Secure Physical Timer Control register (EL2)
   -- D19.12.7 CNTHPS_CVAL_EL2, Counter-timer Secure Physical Timer CompareValue register (EL2)
   -- D19.12.8 CNTHPS_TVAL_EL2, Counter-timer Secure Physical Timer TimerValue register (EL2)
   -- D19.12.9 CNTHV_CTL_EL2, Counter-timer Virtual Timer Control register (EL2)
   -- D19.12.10 CNTHV_CVAL_EL2, Counter-timer Virtual Timer CompareValue register (EL2)
   -- D19.12.11 CNTHV_TVAL_EL2, Counter-timer Virtual Timer TimerValue Register (EL2)
   -- D19.12.12 CNTHVS_CTL_EL2, Counter-timer Secure Virtual Timer Control register (EL2)
   -- D19.12.13 CNTHVS_CVAL_EL2, Counter-timer Secure Virtual Timer CompareValue register (EL2)
   -- D19.12.14 CNTHVS_TVAL_EL2, Counter-timer Secure Virtual Timer TimerValue register (EL2)
   -- D19.12.15 CNTKCTL_EL1, Counter-timer Kernel Control register

   -- D19.12.16 CNTP_CTL_EL0, Counter-timer Physical Timer Control register

   type CNTP_CTL_EL0_Type is record
      ENABLE    : Boolean;      -- Enables the timer.
      IMASK     : Boolean;      -- Timer interrupt mask bit.
      ISTATUS   : Boolean;      -- The status of the timer.
      Reserved1 : Bits_29 := 0;
      Reserved2 : Bits_32 := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CNTP_CTL_EL0_Type use record
      ENABLE    at 0 range  0 ..  0;
      IMASK     at 0 range  1 ..  1;
      ISTATUS   at 0 range  2 ..  2;
      Reserved1 at 0 range  3 .. 31;
      Reserved2 at 0 range 32 .. 63;
   end record;

   function CNTP_CTL_EL0_Read
      return CNTP_CTL_EL0_Type
      with Inline => True;
   procedure CNTP_CTL_EL0_Write
      (Value : in CNTP_CTL_EL0_Type)
      with Inline => True;

   -- D19.12.17 CNTP_CVAL_EL0, Counter-timer Physical Timer CompareValue register

   function CNTP_CVAL_EL0_Read
      return Unsigned_64
      with Inline => True;
   procedure CNTP_CVAL_EL0_Write
      (Value : in Unsigned_64)
      with Inline => True;

   -- D19.12.18 CNTP_TVAL_EL0, Counter-timer Physical Timer TimerValue register

   type CNTP_TVAL_EL0_Type is record
      TimerValue : Unsigned_32;      -- The TimerValue view of the EL1 physical timer.
      Reserved   : Bits_32     := 0;
   end record
      with Bit_Order => Low_Order_First,
           Size      => 64;
   for CNTP_TVAL_EL0_Type use record
      TimerValue at 0 range  0 .. 31;
      Reserved   at 0 range 32 .. 63;
   end record;

   function CNTP_TVAL_EL0_Read
      return CNTP_TVAL_EL0_Type
      with Inline => True;
   procedure CNTP_TVAL_EL0_Write
      (Value : in CNTP_TVAL_EL0_Type)
      with Inline => True;

   -- D19.12.19 CNTPCTSS_EL0, Counter-timer Self-Synchronized Physical Count register

   -- D19.12.20 CNTPCT_EL0, Counter-timer Physical Count register

   function CNTPCT_EL0_Read
      return Unsigned_64
      with Inline => True;

   -- D19.12.21 CNTPS_CTL_EL1, Counter-timer Physical Secure Timer Control register
   -- D19.12.22 CNTPOFF_EL2, Counter-timer Physical Offset register
   -- D19.12.23 CNTPS_CVAL_EL1, Counter-timer Physical Secure Timer CompareValue register
   -- D19.12.24 CNTPS_TVAL_EL1, Counter-timer Physical Secure Timer TimerValue register
   -- D19.12.25 CNTV_CTL_EL0, Counter-timer Virtual Timer Control register
   -- D19.12.26 CNTV_CVAL_EL0, Counter-timer Virtual Timer CompareValue register
   -- D19.12.27 CNTV_TVAL_EL0, Counter-timer Virtual Timer TimerValue register
   -- D19.12.28 CNTVCTSS_EL0, Counter-timer Self-Synchronized Virtual Count register
   -- D19.12.29 CNTVCT_EL0, Counter-timer Virtual Count register
   -- D19.12.30 CNTVOFF_EL2, Counter-timer Virtual Offset register

   ----------------------------------------------------------------------------
   -- Generic definitions
   ----------------------------------------------------------------------------

   procedure NOP
      with Inline => True;
   procedure BREAKPOINT
      with Inline => True;
   procedure Asm_Call
      (Target_Address : in Address)
      with Inline => True;

   ----------------------------------------------------------------------------
   -- Specific definitions
   ----------------------------------------------------------------------------

   procedure WFE
      with Inline => True;
   procedure WFI
      with Inline => True;
   procedure DSB
      with Inline => True;
   procedure ISB
      with Inline => True;

   ----------------------------------------------------------------------------
   -- Exceptions and interrupts
   ----------------------------------------------------------------------------

   procedure Irq_Enable
      with Inline => True;
   procedure Irq_Disable
      with Inline => True;

pragma Style_Checks (On);

end ARMv8A;
