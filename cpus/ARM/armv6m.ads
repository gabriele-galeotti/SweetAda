-----------------------------------------------------------------------------------------------------------------------
--                                                     SweetAda                                                      --
-----------------------------------------------------------------------------------------------------------------------
-- __HDS__                                                                                                           --
-- __FLN__ armv6m.ads                                                                                                --
-- __DSC__                                                                                                           --
-- __HSH__ e69de29bb2d1d6434b8b29ae775ad8c2e48c5391                                                                  --
-- __HDE__                                                                                                           --
-----------------------------------------------------------------------------------------------------------------------
-- Copyright (C) 2020, 2021, 2022 Gabriele Galeotti                                                                  --
--                                                                                                                   --
-- SweetAda web page: http://sweetada.org                                                                            --
-- contact address: gabriele.galeotti@sweetada.org                                                                   --
-- This work is licensed under the terms of the MIT License.                                                         --
-- Please consult the LICENSE.txt file located in the top-level directory.                                           --
-----------------------------------------------------------------------------------------------------------------------

with System;
with System.Storage_Elements;
with Ada.Unchecked_Conversion;
with Interfaces;
with Bits;

package ARMv6M is

   --========================================================================--
   --                                                                        --
   --                                                                        --
   --                               Public part                              --
   --                                                                        --
   --                                                                        --
   --========================================================================--

   pragma Preelaborate;

   use System;
   use System.Storage_Elements;
   use Interfaces;
   use Bits;

   -- B3.2.3 CPUID Base Register

   type CPUID_Type is
   record
      Revision    : Bits_4;
      PartNo      : Bits_12;
      Constant0F  : Bits_4;  -- 0x0F
      Variant     : Bits_4;
      Implementer : Bits_8;  -- 0x41 = ARM
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for CPUID_Type use
   record
      Revision    at 0 range 0 .. 3;
      PartNo      at 0 range 4 .. 15;
      Constant0F  at 0 range 16 .. 19;
      Variant     at 0 range 20 .. 23;
      Implementer at 0 range 24 .. 31;
   end record;

   CPUID_ADDRESS : constant := 16#E000_ED00#;

   CPUID : aliased CPUID_Type with
      Address              => To_Address (CPUID_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   function To_U32 is new Ada.Unchecked_Conversion (CPUID_Type, Unsigned_32);

   -- B3.2.4 Interrupt Control and State Register

   type ICSR_Type is
   record
      VECTACTIVE  : Bits_9;  -- The exception number of the current executing exception.
      Reserved1   : Bits_2;
      RETTOBASE   : Boolean; -- Whether there is an active exception other than the exception shown by IPSR.
      VECTPENDING : Bits_9;  -- The exception number of the highest priority pending and enabled interrupt.
      Reserved2   : Bits_1;
      ISRPENDING  : Boolean; -- Indicates whether an external interrupt, generated by the NVIC, is pending.
      ISRPREEMPT  : Boolean; -- Indicates whether a pending exception will be serviced on exit from debug halt state.
      Reserved3   : Bits_1;
      PENDSTCLR   : Boolean; -- Removes the pending status of the SysTick exception.
      PENDSTSET   : Boolean; -- W: sets the SysTick exception as pending R: indicates the current state of the exception.
      PENDSVCLR   : Boolean; -- Removes the pending status of the PendSV exception.
      PENDSVSET   : Boolean; -- W: sets the PendSV exception as pending. R: indicates the current state of the exception.
      Reserved4   : Bits_2;
      NMIPENDSET  : Boolean; -- W: makes the NMI exception active R: indicates the state of the exception.
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for ICSR_Type use
   record
      VECTACTIVE  at 0 range 0 .. 8;
      Reserved1   at 0 range 9 .. 10;
      RETTOBASE   at 0 range 11 .. 11;
      VECTPENDING at 0 range 12 .. 20;
      Reserved2   at 0 range 21 .. 21;
      ISRPENDING  at 0 range 22 .. 22;
      ISRPREEMPT  at 0 range 23 .. 23;
      Reserved3   at 0 range 24 .. 24;
      PENDSTCLR   at 0 range 25 .. 25;
      PENDSTSET   at 0 range 26 .. 26;
      PENDSVCLR   at 0 range 27 .. 27;
      PENDSVSET   at 0 range 28 .. 28;
      Reserved4   at 0 range 29 .. 30;
      NMIPENDSET  at 0 range 31 .. 31;
   end record;

   ICSR_ADDRESS : constant := 16#E000_ED04#;

   ICSR : aliased ICSR_Type with
      Address              => To_Address (ICSR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.2.5 Vector Table Offset Register

   type VTOR_Type is
   record
      Reserved : Bits_6;
      TBLOFF   : Bits_26; -- Bits[31:7] of the vector table address.
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for VTOR_Type use
   record
      Reserved at 0 range 0 .. 5;
      TBLOFF   at 0 range 6 .. 31;
   end record;

   VTOR_ADDRESS : constant := 16#E000_ED08#;

   VTOR : aliased VTOR_Type with
      Address              => To_Address (VTOR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.2.6 Application Interrupt and Reset Control Register

   ENDIANNESS_LITTLE : constant Bits_1 := 0; -- memory system data endianness = LITTLE
   ENDIANNESS_BIG    : constant Bits_1 := 1; -- memory system data endianness = BIG

   VECTKEY_KEY : constant Bits_16 := 16#05FA#; -- Vector Key

   type AIRCR_Type is
   record
      Reserved1     : Bits_1;
      VECTCLRACTIVE : Boolean; -- Clears all active state information for fixed and configurable exceptions.
      SYSRESETREQ   : Boolean; -- System Reset Request.
      Reserved2     : Bits_12;
      ENDIANNESS    : Bits_1;  -- Indicates the memory system data endianness.
      VECTKEY_STAT  : Bits_16; -- Vector Key.
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for AIRCR_Type use
   record
      Reserved1     at 0 range 0 .. 0;
      VECTCLRACTIVE at 0 range 1 .. 1;
      SYSRESETREQ   at 0 range 2 .. 2;
      Reserved2     at 0 range 3 .. 14;
      ENDIANNESS    at 0 range 15 .. 15;
      VECTKEY_STAT  at 0 range 16 .. 31;
   end record;

   AIRCR_ADDRESS : constant := 16#E000_ED0C#;

   AIRCR : aliased AIRCR_Type with
      Address              => To_Address (AIRCR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.2.7 System Control Register

   type SCR_Type is
   record
      Reserved1   : Bits_1;
      SLEEPONEXIT : Boolean; -- Whether, on an exit from an ISR ..., the processor enters a sleep state.
      SLEEPDEEP   : Boolean; -- Provides a qualifying hint indicating that waking from sleep might take longer.
      Reserved2   : Bits_1;
      SEVONPEND   : Boolean; -- Whether an interrupt transition from inactive state to pending state is a wakeup event.
      Reserved3   : Bits_27;
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for SCR_Type use
   record
      Reserved1   at 0 range 0 .. 0;
      SLEEPONEXIT at 0 range 1 .. 1;
      SLEEPDEEP   at 0 range 2 .. 2;
      Reserved2   at 0 range 3 .. 3;
      SEVONPEND   at 0 range 4 .. 4;
      Reserved3   at 0 range 5 .. 31;
   end record;

   SCR_ADDRESS : constant := 16#E000_ED10#;

   SCR : aliased SCR_Type with
      Address              => To_Address (SCR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.2.8 Configuration and Control Register

   type CCR_Type is
   record
      Reserved1   : Bits_3;
      UNALIGN_TRP : Boolean; -- unaligned word and halfword accesses generate a HardFault exception
      Reserved2   : Bits_5;
      STKALIGN    : Boolean; -- On exception entry, the SP ... is adjusted to be 8-byte aligned.
      Reserved3   : Bits_22;
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for CCR_Type use
   record
      Reserved1   at 0 range 0 .. 2;
      UNALIGN_TRP at 0 range 3 .. 3;
      Reserved2   at 0 range 4 .. 8;
      STKALIGN    at 0 range 9 .. 9;
      Reserved3   at 0 range 10 .. 31;
   end record;

   CCR_ADDRESS : constant := 16#E000_ED14#;

   CCR : aliased CCR_Type with
      Address              => To_Address (CCR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.2.9 System Handler Priority Register 2

   type SHPR2_Type is
   record
      Reserved : Bits_30;
      PRI_11   : Bits_2;  -- Priority of system handler 11, SVCall
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for SHPR2_Type use
   record
      Reserved at 0 range 0 .. 29;
      PRI_11   at 0 range 30 .. 31;
   end record;

   SHPR2_ADDRESS : constant := 16#E000_ED1C#;

   SHPR2 : aliased SHPR2_Type with
      Address              => To_Address (SHPR2_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.2.10 System Handler Priority Register 3

   type SHPR3_Type is
   record
      Reserved1 : Bits_22;
      PRI_14    : Bits_2;  -- Priority of system handler 14, PendSV
      Reserved2 : Bits_6;
      PRI_15    : Bits_2;  -- Priority of system handler 15, SysTick
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for SHPR3_Type use
   record
      Reserved1 at 0 range 0 .. 21;
      PRI_14    at 0 range 22 .. 23;
      Reserved2 at 0 range 24 .. 29;
      PRI_15    at 0 range 30 .. 31;
   end record;

   SHPR3_ADDRESS : constant := 16#E000_ED20#;

   SHPR3 : aliased SHPR3_Type with
      Address              => To_Address (SHPR3_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.2.12 The Auxiliary Control Register
   -- IMPLEMENTATION DEFINED

   type ACTLR_Type is
   record
      Reserved : Bits_32;
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for ACTLR_Type use
   record
      Reserved at 0 range 0 .. 31;
   end record;

   ACTLR_ADDRESS : constant Integer_Address := 16#E000_E008#;

   -- B3.3.3 SysTick Control and Status Register

   CLKSOURCE_EXT : constant Bits_1 := 0; -- SysTick uses the optional external reference clock.
   CLKSOURCE_CPU : constant Bits_1 := 1; -- SysTick uses the processor clock.

   type SYST_CSR_Type is
   record
      ENABLE    : Boolean; -- Indicates the enabled status of the SysTick counter.
      TICKINT   : Boolean; -- Indicates whether counting to 0 causes the status of the SysTick exception to change to pending.
      CLKSOURCE : Bits_1;  -- Indicates the SysTick clock source.
      Reserved1 : Bits_13;
      COUNTFLAG : Boolean; -- Indicates whether the counter has counted to 0 since the last read of this register.
      Reserved2 : Bits_15;
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for SYST_CSR_Type use
   record
      ENABLE    at 0 range 0 .. 0;
      TICKINT   at 0 range 1 .. 1;
      CLKSOURCE at 0 range 2 .. 2;
      Reserved1 at 0 range 3 .. 15;
      COUNTFLAG at 0 range 16 .. 16;
      Reserved2 at 0 range 17 .. 31;
   end record;

   SYST_CSR_ADDRESS : constant := 16#E000_E010#;

   SYST_CSR : aliased SYST_CSR_Type with
      Address              => To_Address (SYST_CSR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.3.4 SysTick Reload Value Register

   type SYST_RVR_Type is
   record
      RELOAD   : Bits_24; -- The value to load into the SYST_CVR register when the counter reaches 0.
      Reserved : Bits_8;
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for SYST_RVR_Type use
   record
      RELOAD   at 0 range 0 .. 23;
      Reserved at 0 range 24 .. 31;
   end record;

   SYST_RVR_ADDRESS : constant := 16#E000_E014#;

   SYST_RVR : aliased SYST_RVR_Type with
      Address              => To_Address (SYST_RVR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.3.5 SysTick Current Value Register

   type SYST_CVR_Type is
   record
      CURRENT  : Bits_24; -- Current counter value.
      Reserved : Bits_8;
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for SYST_CVR_Type use
   record
      CURRENT  at 0 range 0 .. 23;
      Reserved at 0 range 24 .. 31;
   end record;

   SYST_CVR_ADDRESS : constant Integer_Address := 16#E000_E018#;

   SYST_CVR : aliased SYST_CVR_Type with
      Address              => To_Address (SYST_CVR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- B3.3.6 SysTick Calibration Value Register

   type SYST_CALIB_Type is
   record
      TENMS    : Bits_24; -- Optionally, holds a reload value to be used for 10ms (100Hz) timing.
      Reserved : Bits_6;
      SKEW     : Boolean; -- Indicates whether the 10ms calibration value is exact.
      NOREF    : Boolean; -- Indicates whether the IMPLEMENTATION DEFINED reference clock is provided.
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for SYST_CALIB_Type use
   record
      TENMS    at 0 range 0 .. 23;
      Reserved at 0 range 24 .. 29;
      SKEW     at 0 range 30 .. 30;
      NOREF    at 0 range 31 .. 31;
   end record;

   SYST_CALIB_ADDRESS : constant := 16#E000_E01C#;

   SYST_CALIB : aliased SYST_CALIB_Type with
      Address              => To_Address (SYST_CALIB_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   -- C1.6.2 Debug Fault Status Register

   type DFSR_Type is
   record
      HALTED   : Boolean; -- Indicates a debug event generated by a C_HALT or C_STEP request.
      BKPT     : Boolean; -- Indicates a debug event generated by BKPT instruction execution or a bkpt match in the BPU.
      DWTTRAP  : Boolean; -- Indicates a debug event generated by the DWT.
      VCATCH   : Boolean; -- Indicates whether a vector catch debug event was generated.
      EXTERNAL : Boolean; -- Indicates an asynchronous debug event generated because of EDBGRQ being asserted.
      Reserved : Bits_27;
   end record with
      Bit_Order => Low_Order_First,
      Size      => 32;
   for DFSR_Type use
   record
      HALTED   at 0 range 0 .. 0;
      BKPT     at 0 range 1 .. 1;
      DWTTRAP  at 0 range 2 .. 2;
      VCATCH   at 0 range 3 .. 3;
      EXTERNAL at 0 range 4 .. 4;
      Reserved at 0 range 5 .. 31;
   end record;

   DFSR_ADDRESS : constant := 16#E000_ED30#;

   DFSR : aliased DFSR_Type with
      Address              => To_Address (DFSR_ADDRESS),
      Volatile_Full_Access => True,
      Import               => True,
      Convention           => Ada;

   ----------------------------------------------------------------------------
   -- Generic definitions
   ----------------------------------------------------------------------------

   procedure NOP with
      Inline => True;
   procedure BREAKPOINT with
      Inline => True;

   ----------------------------------------------------------------------------
   -- Exceptions and interrupts
   ----------------------------------------------------------------------------

   procedure Irq_Enable with
      Inline => True;
   procedure Irq_Disable with
      Inline => True;

   ----------------------------------------------------------------------------
   -- Locking
   ----------------------------------------------------------------------------

   procedure Memory_Synchronization with
      Inline        => True,
      Export        => True,
      Convention    => C,
      External_Name => "__sync_synchronize";

end ARMv6M;
